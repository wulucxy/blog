<!doctype html><html lang="en"><head><meta charset="utf-8"><link rel="shortcut icon" href="/blog/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="theme-color" content="#000000"><link rel="manifest" href="/blog/manifest.json"><link rel="canonical" href="/blog/posts/2019-08-01/typescript-redux/" />

    <title data-react-helmet="true">大型项目 typescript + redux 实践</title>
    
    
  <link rel="stylesheet" href="/blog/static/css/1.7e9e0c37.chunk.css" /><link href="/blog/static/css/main.d6f6a394.chunk.css" rel="stylesheet"></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div id="root"><div class="BlogLayout_container__2z5VE"><div class="
        LoadingIndicator_LoadingIndicator__LI6x0
        
        undefined
      "></div><header><h3 class="BlogLayout_title__nZ4wJ"><a class=" " href="/">qingtong Blog</a></h3></header><main><article><header class="BlogPostLayout_header__hNrNi"><h1 class="BlogPostLayout_title__j9S_E"><a class=" " href="/posts/2019-08-01/typescript-redux/">大型项目 typescript + redux 实践</a></h1><small><time dateTime="Wed, 31 Jul 2019 16:00:00 GMT">August 1, 2019</time> <!-- -->•<!-- --> <ul class="ArticleMeta_tags__bwcp_"><li><a class=" " href="/tags/typescript/">typescript</a></li><li><a class=" " href="/tags/redux/">redux</a></li></ul> <!-- -->•<!-- --> <span>☕️<!-- --> <!-- -->5<!-- --> min read</span></small></header><div class="BlogPostLayout_content__3oTIu"><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-08-01-typescript-redux/image/ts.png" alt="image"/></p><h3 id="前言">前言</h3><p>typescript 是一个有着类型定义的 js 语言的超集。typescript 支持最新的 ESMAScript 特性，并且支持泛型、类型定义等静态语言特征，<strong>是为了大规模应用而生</strong>。我们团队之前在内部一些项目中初步尝试了 <code>React + Redux + TypeScript</code> 组合。本文则尝试梳理基于 <code>typescript</code> 如何更合理的架构 <code>redux</code>。</p><h2 id="一-环境配置">一. 环境配置</h2><p>当前 <code>ts + react</code> 项目基础配置如下：</p><ul><li>编译：@babel/preset-typescript</li><li>开发、打包：parcel</li><li>语法校验：eslint、tsc</li></ul><p>其中引入 <code>babel/preset</code> 来替代 <code>ts-loader</code>，这样既解决了 ts 工程化构建效率问题，同时不影响类型校验，还统一了编译工具。</p><p>接入 <code>babel</code> 以后，需要对 <code>tsconfig</code> 规则稍作修改，此时 ts 的定位仅仅是类型校验，代码编译的工作就完全交给 <code>babel</code> 来处理了。</p><p><em>tsconfig.json</em></p><pre><code class="language-json" data-language="json" data-highlighted-line-numbers=""><span class="token punctuation">{</span>
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 解析为最新版本的es版本，babel 负责后续的编译</span>
    <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"esnext"</span><span class="token punctuation">,</span>
    <span class="token property">"module"</span><span class="token operator">:</span> <span class="token string">"esnext"</span><span class="token punctuation">,</span>
    <span class="token comment">// ts 的解析规则</span>
    <span class="token property">"lib"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"esnext"</span><span class="token punctuation">,</span> <span class="token string">"dom"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment">// 绝对地址按照 node_modules 解析</span>
    <span class="token property">"moduleResolution"</span><span class="token operator">:</span> <span class="token string">"node"</span><span class="token punctuation">,</span>
    <span class="token comment">// 开启 jsx</span>
    <span class="token property">"jsx"</span><span class="token operator">:</span> <span class="token string">"react"</span><span class="token punctuation">,</span>
    <span class="token comment">// 不执行构建，交由 babel 执行</span>
    <span class="token property">"noEmit"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 严格模式，包括 strictNullChecks &amp; noImplicitAny.</span>
    <span class="token property">"strict"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 跳过三方包检查</span>
    <span class="token property">"skipLibCheck"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// any 类型不警告</span>
    <span class="token property">"noImplicitAny"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 关闭 null 严格检查</span>
    <span class="token property">"strictNullChecks"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token comment">// 将每个文件作为单独的模块</span>
    <span class="token property">"isolatedModules"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// Import non-ES modules as default imports.</span>
    <span class="token property">"esModuleInterop"</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"include"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>接下来还需要配置 <code>eslint</code> 规则：</p><p><em>.eslintrc</em></p><pre><code class="language-json" data-language="json" data-highlighted-line-numbers=""><span class="token punctuation">{</span>
  <span class="token property">"parser"</span><span class="token operator">:</span> <span class="token string">"@typescript-eslint/parser"</span><span class="token punctuation">,</span>
  <span class="token property">"parserOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"project"</span><span class="token operator">:</span> <span class="token string">"./tsconfig.json"</span><span class="token punctuation">,</span>
    <span class="token property">"ecmaVersion"</span><span class="token operator">:</span> <span class="token number">2018</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"extends"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">"@wac/standard/react"</span><span class="token punctuation">,</span>
    <span class="token string">"plugin:@typescript-eslint/recommended"</span><span class="token punctuation">,</span>
    <span class="token string">"prettier"</span><span class="token punctuation">,</span>
    <span class="token string">"prettier/@typescript-eslint"</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">"plugins"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"@typescript-eslint"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">"rules"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 自定义 lint 规则</span>
    <span class="token property">"react/prop-types"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token property">"@typescript-eslint/no-explicit-any"</span><span class="token operator">:</span> <span class="token string">"warn"</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre><p>最后一步就是在 <code>package.json</code> 里面添加脚本命令了：</p><p><em>package.json</em></p><pre><code class="language-json" data-language="json" data-highlighted-line-numbers=""><span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token property">"start"</span><span class="token operator">:</span> <span class="token string">"parcel src/public/index.html --open"</span><span class="token punctuation">,</span>
  <span class="token property">"prebuild"</span><span class="token operator">:</span> <span class="token string">"npm run build:clean"</span><span class="token punctuation">,</span>
  <span class="token property">"build:clean"</span><span class="token operator">:</span> <span class="token string">"rimraf ./dist"</span><span class="token punctuation">,</span>
  <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"parcel build src/public/index.html --no-source-maps"</span><span class="token punctuation">,</span>
  <span class="token property">"lint"</span><span class="token operator">:</span> <span class="token string">"eslint src --fix --format codeframe"</span><span class="token punctuation">,</span>
  <span class="token property">"lint-staged"</span><span class="token operator">:</span> <span class="token string">"lint-staged"</span><span class="token punctuation">,</span>
  <span class="token property">"ts-compile-check"</span><span class="token operator">:</span> <span class="token string">"tsc --pretty -p tsconfig.json"</span>
<span class="token punctuation">}</span>
</code></pre><p>以上，我们就实现了一套完整工程化能力的 <code>typescript</code> 开发环境了。</p><blockquote><p>let’s RUN~~~</p></blockquote><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-08-01-typescript-redux/image/run.png" alt="run"/></p><h2 id="二-数据和分层">二. 数据和分层</h2><h3 id="1-目录结构">1. 目录结构</h3><p>目录即分层，一个好的目录结构能够让我们在开发中更加得心应手。在开发 redux 应用中，有一种普遍的做法是根据 <code>action</code>, <code>reducer</code> 功能进行分层，一个典型的应用是这样的：</p><pre><code>.
|-- actions             // 全局 action
|-- components          // 公共组件
|   |-- Footer.tsx
|   |-- Header.tsx
|-- pages               // 页面
|   |-- home
|      |-- components  // 组件入口  
|      `-- index.tsx   // 页面入口 
|-- reducers           // 全局 reducer
|-- store              // store 入口
|-- types.d.ts         // 三方类型声明
</code></pre><p>在实际开发中，开发往往会在不同文件中来回跳跃，尤其是当项目文件膨胀以后，在不同文件中跳跃式寻找会占据很大比例的时间。基于此，社区开始流行另外一种开发方式，俗称「ducks」规则，简而言之就是将 <code>action</code>, <code>reducer</code>，<code>actionType</code> 放在一起进行管理，<a class=" " href="https://github.com/erikras/ducks-modular-redux">参考链接</a>。 其中 <code>ducks</code> 命名来自于<code>redux</code> 结尾音。</p><p><strong>ducks</strong></p><pre><code>.
|-- components           // 公共组件
|   |-- Footer.tsx
|   |-- Header.tsx
|-- pages
|   |-- home
|   |  |-- index.ts      // 页面入口
|   |  |-- components    // 组件
|   |  |-- types.ts      // 类型声明
|   |  `-- reducer.ts    // action/reducer
|-- store                 // redux store 入口
|-- types.d.ts            // 三方组件类型声明
</code></pre><h3 id="2-数据不可变性">2. 数据不可变性</h3><p>在 redux 开发中，需要遵循的一个原则是<code>数据不可变性 (immutable)</code>，每个 reducer 不能修改原始值，而只能返回一个新的 state。</p><p>在 接触 <code>typescript</code> 之前，<a class=" " href="https://immutable-js.github.io/immutable-js/">immutable.js</a> 是结合 redux 实现数据不可变的最佳辅助工具。然而，<code>immutable.js</code> 对 <code>ts</code> 的支持就一言难尽了，这两者都是很好的工具，但是放在一起，却是那么的不合适。</p><p>所以我们在实际项目中尝试了使用 <a class=" " href="https://github.com/immerjs/immer">immer</a> 来实现数据持久化，<code>immer</code> 通过 <code>proxy</code> 实现了用原生 js 语法实现了数据不可变。虽然写起来没有像 <code>immutable.js</code> 函数式写法那么爽，但至少能用。</p><blockquote><p>后续，我们仍然会探索基于 <code>immutable.js</code> 的 <code>typescript</code> 写法，不再本文范畴之内。</p></blockquote><h3 id="3-store">3. Store</h3><p>在 <code>Store</code> 中我们将 <code>reducer</code> 进行聚合，并对外导出应用级别的状态数据。</p><p><em>src/store/root-reducers.ts</em></p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token comment">// 页面 reducer 聚合</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> ReducersMapObject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"redux"</span>
<span class="token comment">// 导入每个页面独立的 reducer 和 类型声明</span>
<span class="token keyword">import</span> bitcoin <span class="token keyword">from</span> <span class="token string">"../pages/basic/reducer"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> BitcoinState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../pages/basic/types"</span><span class="token punctuation">;</span>

<span class="token comment">// 应用级数据类型接口</span>
<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">AppState</span> <span class="token punctuation">{</span>
  bitcoin<span class="token operator">:</span> BitcoinState<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> reducers<span class="token operator">:</span> ReducersMapObject <span class="token operator">=</span> <span class="token punctuation">{</span>
  bitcoin
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> reducers 
</code></pre><p><em>src/store/create.ts</em></p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token comment">// 导入 redux 和 immer 相应的方法</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createStore<span class="token punctuation">,</span> Reducer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux'</span>
<span class="token keyword">import</span> produce <span class="token keyword">from</span> <span class="token string">"immer"</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> combineReducers <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"redux-immer"</span>

<span class="token comment">// 聚合后的 reducer 和顶层应用数据</span>
<span class="token keyword">import</span> reducers<span class="token punctuation">,</span> <span class="token punctuation">{</span> AppState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./root-reducer"</span>

<span class="token comment">// 通过 combineReducer 将 reducer 合并为一</span>
<span class="token comment">// 注意这里的 combineReducers 是基于 immer 的实现</span>
<span class="token keyword">const</span> rootReducer<span class="token operator">:</span> Reducer<span class="token operator">&lt;</span>AppState<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">combineReducers</span><span class="token punctuation">(</span>produce<span class="token punctuation">,</span> reducers<span class="token punctuation">)</span>

<span class="token comment">// 导出 store</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">initialState <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">createStore</span><span class="token punctuation">(</span>
    rootReducer<span class="token punctuation">,</span>
    initialState<span class="token punctuation">,</span>
    <span class="token function">applyMiddleware</span><span class="token punctuation">(</span>Thunk<span class="token punctuation">,</span> promiseMiddleware<span class="token punctuation">,</span> Logger<span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="4-声明类型文件-dts">4. 声明类型文件 .d.ts</h3><p>我们在项目中会依赖到很多三方、二方包仍然是用纯 js 实现的，将这些代码重构为 <code>typescript</code> 显然是不现实的，ts 的做法是我们可以声明 <code>.d.ts</code> 类型文件将三方包引入到 ts 工程中。</p><p><code>.d.ts</code> 中 <code>d</code> 的含义是 <code>declaration</code> 即声明，实际使用我们无需关注具体实现，而只需要导出类型声明即可。</p><p>最简单的声明文件是这样的：</p><pre><code>declare module &#x27;@wac/r3&#x27;
</code></pre><p>但是如果你的项目中类型声明非常重要的话，建议到 <a class=" " href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> 查看更多优质类型定义文件，并贡献自己的力量。</p><p>在声明类型文件还有一种<strong>取巧的做法</strong>是定义全局类型，全局类型无需导入即可对所有文件可见，举例：</p><p><em>typing.d.ts</em></p><pre><code>interface IUser {
  name: string
  phone: number
}
</code></pre><p>定义好之后你在任意文件中都可以直接使用该类型。</p><p>实际上这样做有可商榷之处，在导入三方类型声明的文件中，用来声明当前应用的全局类型。这样的做法 <a class=" " href="https://stackoverflow.com/questions/42233987/how-to-configure-custom-global-interfaces-d-ts-files-for-typescript">社区并不推荐</a>。实际上你应该定义一个独立的 <code>.ts</code> 文件，然后通过 <code>export/import</code> 来引用。</p><h2 id="三-reducer">三. reducer</h2><p>前面我们提到将 <code>reducer</code>，<code>action</code>，<code>actionType</code> 按照 <code>ducks</code> 规则统一到一个文件中管理, 并且将<strong>类型声明</strong>也统一到一个文件。接下来我们展开来介绍这部分内容：</p><h3 id="1-types">1. types</h3><p><code>actionType</code> 是一种可枚举类型：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">export</span> <span class="token keyword">enum</span> BitcoinActionTypes <span class="token punctuation">{</span>
  <span class="token comment">// 请求比特币周期价格指数</span>
  <span class="token constant">BITCOIN_QUERY_LIST</span> <span class="token operator">=</span> <span class="token string">"BITCOIN_QUERY_LIST"</span><span class="token punctuation">,</span>
  <span class="token comment">// 请求比特币当前价格</span>
  <span class="token constant">BITCOIN_QUERY_CURRENCY</span> <span class="token operator">=</span> <span class="token string">"BITCOIN_QUERY_CURRENCY"</span><span class="token punctuation">,</span>
  <span class="token comment">// 设置当前过滤条件</span>
  <span class="token constant">BITCOIN_SET_FILTER</span> <span class="token operator">=</span> <span class="token string">"BITCOIN_SET_FILTER"</span>
<span class="token punctuation">}</span>
</code></pre><p>通过枚举类型结合 <code>typescript</code> 的强类型自动推导能力，可以实现开发自动输入补全：
<img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-08-01-typescript-redux/image/infer.png" alt="enum"/></p><h3 id="2-actions">2. actions</h3><p>redux 中的 <code>action</code> 分为两类：同步和异步。</p><p><strong>同步 action</strong></p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">import</span> <span class="token punctuation">{</span> BitcoinActionTypes <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./types"</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">setFilterType</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">filterType<span class="token operator">:</span> string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  type<span class="token operator">:</span> BitcoinActionTypes<span class="token punctuation">.</span><span class="token constant">BITCOIN_SET_FILTER</span><span class="token punctuation">,</span>
  payload<span class="token operator">:</span> <span class="token punctuation">{</span> filterType <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>借助 <code>typeof</code> 关键词，我们在<code>types</code> 文件中非常方便地导出类型：</p><p><em>types.ts</em></p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">import</span> <span class="token punctuation">{</span> setFilterType <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./reducer"</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> type SetFilterType <span class="token operator">=</span> <span class="token keyword">typeof</span> setFilterType<span class="token punctuation">;</span>
</code></pre><p><strong>异步 action</strong></p><p>在项目中我们使用了 <a class=" " href="https://github.com/pburtchaell/redux-promise-middleware">redux-promise-middleware</a> 进行异步 action 的管理，异步 action 会返回 promise，但是写法仍然沿用同步 action 的写法。</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">import</span> <span class="token punctuation">{</span> AsyncAction <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"redux-promise-middleware"</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> queryBPICurrency <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token parameter">AsyncAction</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    type<span class="token operator">:</span> BitcoinActionTypes<span class="token punctuation">.</span><span class="token constant">BITCOIN_QUERY_CURRENCY</span><span class="token punctuation">,</span>
    <span class="token comment">// 这里这里payload 实际返回的是 promise</span>
    payload<span class="token operator">:</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"//api.coindesk.com/v1/bpi/currentprice/cny.json"</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>注意这里的 <code>AsyncAction</code> 来自 <code>redux-promise-middleware</code> 的 <a class=" " href="https://github.com/pburtchaell/redux-promise-middleware/blob/master/src/index.d.ts">类型定义</a>。</p><p>通过 <code>typeof</code> 类型推导:</p><p><em>types.ts</em></p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">import</span> <span class="token punctuation">{</span> queryBPI <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./reducer"</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> type QueryBPI <span class="token operator">=</span> <span class="token keyword">typeof</span> queryBPI
</code></pre><p>结果如下：</p><pre><code>type QueryBPI = (params: BPIParams) =&gt; AsyncAction
</code></pre><h3 id="3reducer">3.reducer</h3><p>结合<code>redux-promise-middleware</code>，<code>type-to-reducer</code> 和 <code>immer</code>，我们来完成具备类型的 <code>reducer</code>。</p><p><em>types.ts</em></p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token comment">// state 类型</span>
<span class="token comment">// 其中 Record 泛型是 `{ [key: string]: T }` 的简写</span>
<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">BitcoinState</span> <span class="token punctuation">{</span>
  filterType<span class="token operator">:</span> string<span class="token punctuation">;</span>
  requestLoading<span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  currentPrice<span class="token operator">:</span> Record<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> BitcoinPrice<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>reducer.ts</strong></p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">import</span> typeToReducer <span class="token keyword">from</span> <span class="token string">"type-to-reducer"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> BitcoinActionTypes<span class="token punctuation">,</span> BPIParams <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./types"</span><span class="token punctuation">;</span>

<span class="token comment">// 导出 reducer</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">typeToReducer</span><span class="token punctuation">(</span>
  <span class="token comment">// 同步 action</span>
  <span class="token punctuation">[</span>BitcoinActionTypes<span class="token punctuation">.</span><span class="token constant">BITCOIN_SET_FILTER</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> filterType <span class="token punctuation">}</span> <span class="token operator">=</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">;</span>
    <span class="token comment">// immer 包装后可以直接用原生 js 修改值</span>
    state<span class="token punctuation">.</span>filterType <span class="token operator">=</span> filterType<span class="token punctuation">;</span>
    <span class="token keyword">return</span> state<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 异步action</span>
  BitcoinActionTypes<span class="token punctuation">.</span><span class="token constant">BITCOIN_QUERY_CURRENCY</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">PENDING</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>requestLoading <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token keyword">return</span> state
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">FULFILLED</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> bpi <span class="token punctuation">}</span> <span class="token operator">=</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">;</span>
      state<span class="token punctuation">.</span>currentPrice <span class="token operator">=</span> bpi<span class="token punctuation">;</span>
      <span class="token keyword">return</span> state<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre><h2 id="四-连接组件">四. 连接组件</h2><p>接下来我们将类型化后的 redux 连接到 React 组件：</p><h3 id="1-connect-连接">1. connect 连接</h3><p>react 组件和 redux 通过 <code>react-redux</code> 的 connect 方法进行连接：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">import</span> <span class="token punctuation">{</span> connect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"react-redux"</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> AppState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../../store/root-reducer"</span><span class="token punctuation">;</span>

<span class="token comment">// 导入类型</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>
  SetFilterType<span class="token punctuation">,</span>
  QueryBPICurrency<span class="token punctuation">,</span>
  QueryBPI<span class="token punctuation">,</span>
  BitcoinState<span class="token punctuation">,</span>
  BPIParams
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./types"</span>

<span class="token comment">// 类型扩展</span>
<span class="token keyword">interface</span> <span class="token class-name">BasicProps</span> <span class="token keyword">extends</span> <span class="token class-name">BitcoinState</span> <span class="token punctuation">{</span>
  setFilterType<span class="token operator">:</span> SetFilterType<span class="token punctuation">;</span>
  queryBPICurrency<span class="token operator">:</span> QueryBPICurrency<span class="token punctuation">;</span>
  queryBPI<span class="token operator">:</span> QueryBPI<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这里通过 Class 组件引入类型</span>
<span class="token comment">// 如果是函数式组件，就使用 React.FC&lt;BasicProps> 声明类型</span>
<span class="token keyword">class</span> <span class="token class-name">Basic</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token operator">&lt;</span>BasicProps<span class="token operator">></span><span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// do something</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 将 state 数据导出为属性</span>
<span class="token keyword">const</span> <span class="token function-variable function">select</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token operator">:</span> AppState</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> bitcoin <span class="token punctuation">}</span> <span class="token operator">=</span> state<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    requestLoading<span class="token operator">:</span> bitcoin<span class="token punctuation">.</span>requestLoading<span class="token punctuation">,</span>
    filterType<span class="token operator">:</span> bitcoin<span class="token punctuation">.</span>filterType<span class="token punctuation">,</span>
    currentPrice<span class="token operator">:</span> <span class="token keyword">get</span><span class="token punctuation">(</span>bitcoin<span class="token punctuation">,</span> <span class="token string">"currentPrice.CNY"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 最后一步：完成 redux 和 组件的连接</span>
<span class="token comment">// 顺便导入一下 action</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">connect</span><span class="token punctuation">(</span>
  select<span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    setFilterType<span class="token punctuation">,</span>
    queryBPI<span class="token punctuation">,</span>
    queryBPICurrency
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">(</span>Basic<span class="token punctuation">)</span>
</code></pre><p>到此，我们就基本上完成了一个 <code>typescript + redux + react</code> 的应用，<em>源码后续会放出</em>。</p><h2 id="总结">总结</h2><blockquote><p>这 ts 有什么用，限制多，运行慢，除了带给我一堆警告，还有什么作用？</p><p>ts 类型声明这么复杂，还引入了这么多新概念，跟框架兼容性又这么差</p><p>我就是辞职，不写前端了，也特么不用巨硬造的假 java</p><p>……</p><p>ts 真香，再也不想用 js 了。</p></blockquote><p>学习 <code>typescript</code> 是一段漫长的旅程，学习 ts 语法并不难，难的是框架对 ts 的支持度。以 React 为例，单单写一个 redux 版本的基础应用就踩了很多坑，甚至为了写 ts 不得不抛弃了<code>immutable.js</code>  — 一个数据不可变函数式工具，更不用提社区数量繁多的其他三方库了。</p><p>ts 不是银弹，ts 无法解决你的代码结构问题，也不能避免语法 Bug，<strong>”彼之蜜糖,吾之毒药“</strong>，当 ts 类型使用不当的时候，强行接入反而会给你造成更大的困扰。</p><p><strong>ts 适合什么场景？</strong></p><p>我个人认为:</p><ol><li><p>中大型项目，需要长期维护的项目，底层库 or 框架</p></li><li><p>上一条的前提是，项目主要依赖的类库对 ts 支持良好，最好有业界的先行案例</p></li></ol><p>所以用一些冷门框架或者小项目的时候我是不建议使用 ts 的，ts 没问题，框架也没问题，框架+ ts 会有很多问题。</p></div><footer class="BlogPostLayout_footer__1TyyS"><h3 class="BlogPostLayout_title__j9S_E"><a class=" " href="/">qingtong Blog</a></h3><div class="
      Bio_Bio__iDVYA
      BlogPostLayout_bio__2WXr0
    "><img src="https://www.gravatar.com/avatar/aa99b351245441b8ca95d54a52d2998c.jpg?s=56&amp;d=identicon" alt="Me"/><p>来自接地气的一线实践开发经验，用心做原创<br/>分享关于 React、数据可视化、效率工具等，打造专业前端知识库</p></div><section class="BlogPostLayout_links__1fL9M"><a class=" " href="/posts/2020-02-19/table-search-design/">← <!-- -->查询 + Table 组件设计</a><a class="BlogPostLayout_next__1lwtu " href="/posts/2019-04-26/webkit-structure/">webkit 浏览器架构<!-- --> →</a></section></footer></article></main></div></div><script>!function(f){function e(e){for(var t,r,n=e[0],o=e[1],a=e[2],c=0,u=[];c<n.length;c++)r=n[c],d[r]&&u.push(d[r][0]),d[r]=0;for(t in o)Object.prototype.hasOwnProperty.call(o,t)&&(f[t]=o[t]);for(p&&p(e);u.length;)u.shift()();return l.push.apply(l,a||[]),i()}function i(){for(var e,t=0;t<l.length;t++){for(var r=l[t],n=!0,o=1;o<r.length;o++){var a=r[o];0!==d[a]&&(n=!1)}n&&(l.splice(t--,1),e=s(s.s=r[0]))}return e}var r={},u={19:0},d={19:0},l=[];function s(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return f[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.e=function(l){var e=[];u[l]?e.push(u[l]):0!==u[l]&&{1:1,10:1,17:1}[l]&&e.push(u[l]=new Promise(function(e,n){for(var t="static/css/"+({}[l]||l)+"."+{1:"7e9e0c37",2:"31d6cfe0",3:"31d6cfe0",4:"31d6cfe0",5:"31d6cfe0",6:"31d6cfe0",7:"31d6cfe0",8:"31d6cfe0",9:"31d6cfe0",10:"17ee5b7e",11:"31d6cfe0",12:"31d6cfe0",13:"31d6cfe0",14:"31d6cfe0",15:"31d6cfe0",16:"31d6cfe0",17:"b0f02a97"}[l]+".chunk.css",o=s.p+t,r=document.getElementsByTagName("link"),a=0;a<r.length;a++){var c=(f=r[a]).getAttribute("data-href")||f.getAttribute("href");if("stylesheet"===f.rel&&(c===t||c===o))return e()}var u=document.getElementsByTagName("style");for(a=0;a<u.length;a++){var f;if((c=(f=u[a]).getAttribute("data-href"))===t||c===o)return e()}var i=document.createElement("link");i.rel="stylesheet",i.type="text/css",i.onload=e,i.onerror=function(e){var t=e&&e.target&&e.target.src||o,r=new Error("Loading CSS chunk "+l+" failed.\n("+t+")");r.request=t,n(r)},i.href=o,document.getElementsByTagName("head")[0].appendChild(i)}).then(function(){u[l]=0}));var r=d[l];if(0!==r)if(r)e.push(r[2]);else{var t=new Promise(function(e,t){r=d[l]=[e,t]});e.push(r[2]=t);var n,o=document.getElementsByTagName("head")[0],a=document.createElement("script");a.charset="utf-8",a.timeout=120,s.nc&&a.setAttribute("nonce",s.nc),a.src=s.p+"static/js/"+({}[l]||l)+"."+{1:"c2cb174b",2:"6b76d4c7",3:"91d9b728",4:"418e8258",5:"1817cc94",6:"c5258100",7:"c0f1f6a4",8:"696a923b",9:"22a94885",10:"99d28899",11:"71b25eb2",12:"cb1159b5",13:"d97a73e2",14:"e74afb6e",15:"bde007d1",16:"da680be3",17:"43db5ace"}[l]+".chunk.js",n=function(e){a.onerror=a.onload=null,clearTimeout(c);var t=d[l];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),n=e&&e.target&&e.target.src,o=new Error("Loading chunk "+l+" failed.\n("+r+": "+n+")");o.type=r,o.request=n,t[1](o)}d[l]=void 0}};var c=setTimeout(function(){n({type:"timeout",target:a})},12e4);a.onerror=a.onload=n,o.appendChild(a)}return Promise.all(e)},s.m=f,s.c=r,s.d=function(e,t,r){s.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(t,e){if(1&e&&(t=s(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(s.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)s.d(r,n,function(e){return t[e]}.bind(null,n));return r},s.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(t,"a",t),t},s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},s.p="/blog/",s.oe=function(e){throw console.error(e),e};var t=window.webpackJsonp=window.webpackJsonp||[],n=t.push.bind(t);t.push=e,t=t.slice();for(var o=0;o<t.length;o++)e(t[o]);var p=n;i()}([])</script><script src="/blog/static/js/18.3029b03e.chunk.js"></script><script src="/blog/static/js/main.b1df4670.chunk.js"></script></body></html>