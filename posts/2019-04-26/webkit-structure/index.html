<!doctype html><html lang="en"><head><meta charset="utf-8"><link rel="shortcut icon" href="/blog/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="theme-color" content="#000000"><link rel="manifest" href="/blog/manifest.json"><link rel="canonical" href="/blog/posts/2019-04-26/webkit-structure/" />

    <title data-react-helmet="true">webkit 浏览器架构</title>
    
    
  <link rel="stylesheet" href="/blog/static/css/1.e905a530.chunk.css" /><link href="/blog/static/css/main.bed4220f.chunk.css" rel="stylesheet"></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div id="root"><div class="BlogLayout_container__19lh5"><div class="
        LoadingIndicator_LoadingIndicator__2SjMh
        
        undefined
      "></div><header><h3 class="BlogLayout_title__2xGgi"><a class=" " href="/">qingtong Blog</a></h3></header><main><article><header class="BlogPostLayout_header__1sA8-"><h1 class="BlogPostLayout_title__r71Bd"><a class=" " href="/posts/2019-04-26/webkit-structure/">webkit 浏览器架构</a></h1><small><time dateTime="Thu, 25 Apr 2019 16:00:00 GMT">April 26, 2019</time> <!-- -->•<!-- --> <ul class="ArticleMeta_tags__Gd2rG"><li><a class=" " href="/tags/webkit/">webkit</a></li></ul> <!-- -->•<!-- --> <span>☕️<!-- --> <!-- -->2<!-- --> min read</span></small></header><div class="BlogPostLayout_content__2eimG"><blockquote><p>来自网友 @cukunbu 原创</p></blockquote><h2 id="process-and-thread">Process and Thread.</h2><ul><li>thread 是 process 的一部分</li></ul><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/process-thread.png" alt="process and threads"/></p><ul><li>可以开启多个 process，process 之间通过  <strong>IPC（Inter Process Communication）</strong>  交互。</li></ul><h2 id="浏览器架构">浏览器架构</h2><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/browserui.png" alt="Chrome processes"/></p><table><thead><tr><th>process 类型</th><th>内容</th></tr></thead><tbody><tr><td>Browser</td><td>1. chrome 应用。包含 address bar, bookmarks, back and forward buttons. 2. 还处理Web浏览器的不可见特权部分，例如网络请求和文件访问。</td></tr><tr><td>Renderer</td><td>tab 内容展示</td></tr><tr><td>Plugin</td><td>浏览器插件，比如 flash</td></tr><tr><td>GPU</td><td>处理其他 process 的 GPU 任务</td></tr></tbody></table><ul><li>每个 Tab/iframe 会运行一个独立的 render process。<ul><li>独立 render process 可以当某个 Tab 崩溃，其他 Tab 正常工作</li><li>独立 render process 保证了每个 iframe 访问的数据必须满足 same origin(同源政策) 。</li></ul></li></ul><h2 id="页面跳转">页面跳转</h2><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/browserprocesses.png" alt="thread"/></p><p>从 browser process 开始，包含 UI thread / Network thread / storage thread</p><h3 id="步骤：">步骤：</h3><ul><li><p>输入网址</p></li><li><p>回车确认</p><ul><li>UI thread 初始化请求， network thread 查询 DNS / 建立 TLS 连接。此时 UI thread 使 tab 转圈圈。</li><li>这个过程中 network thread 与 UI thread 会相互通信，比如301，network 会让 UI thread 重新请求</li></ul></li><li><p>接收请求</p><ul><li><p>MIME-TYPE 校验</p></li><li><p>跨域校验</p></li><li><p>根据 MIME-TYPE 渲染数据</p></li></ul></li></ul><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/response.png" alt="HTTP response"/></p><ul><li><p>如果请求是 HTML ，则渲染页面</p><ul><li>UI thread 寻找对应的 renderer process 渲染</li></ul></li><li><p>renderer process 执行渲染</p></li><li><p>渲染完成</p><ul><li>render process 通知 browser process </li></ul></li><li><p>如果有新的 url 输入，页面需要跳转</p><ul><li>browser process 通知 render process 处理 unloaded 事件</li></ul></li></ul><h3 id="service-worker">service worker</h3><blockquote><p>service worker 会对 network 做代理，允许用户选择读取 cache 还是发送请求获取新数据。</p></blockquote><p><strong>service worker</strong> 是 js 脚本，在 render process 中运行。但是 network thread 存在在 browser process 中，browser process 要如何知晓 render process 中存在 service worker 呢？</p><p>注册 service worker 时，会在 Network thread 中留下引用值。<a class=" " href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle">相关链接</a></p><h2 id="renderer-process-处理页面渲染">renderer process 处理页面渲染</h2><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/renderer.png" alt="Renderer process"/></p><ul><li>Main thread 会处理大部分内容，包括 parsing / style 计算 / layout 构建 / paint 操作/ js 执行</li><li>composition 则在单独的 compositor 执行</li></ul><h3 id="parsing">parsing</h3><ul><li>解析 DOM。对错误处理友好。</li><li>可以边解析 DOM，边请求 <code>&lt;img/&gt;</code> 等资源</li><li>js 会 block parsing</li></ul><blockquote><p><code>&lt;script&gt;</code> 标签添加 async / defer。这样不会阻断主流程
<code>&lt;link rel=&quot;preload&quot;&gt;</code> 添加 preload 标志，告诉浏览器你希望这个资源能尽快下载.</p></blockquote><h3 id="style-计算">style 计算</h3><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/computedstyle.png" alt="computed style"/></p><h3 id="layout">Layout</h3><p>浏览器会构建一个与 DOM 树类似的树，展示 x, y, width, height 信息。伪类元素也会在这个阶段应用。</p><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/layout.png" alt="layout"/></p><h3 id="paint">paint</h3><p>在这个阶段还需计算组件的 order。Layout 树会被遍历产生一个 Paint Record.</p><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/paint.png" alt="paint records"/></p><ul><li>以 pipeline 的方式进行更新</li></ul><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/pipeline.png" alt="image-20190422224904804"/></p><ul><li>js 也在 main thread 中进行，会阻碍渲染</li></ul><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/pagejank2.png" alt="jage jank by JavaScript"/></p><p>可以将 js 操作颗粒化，可以使用 requestAnimationFrame() / web worker</p><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/raf.png" alt="request animation frame"/></p><h3 id="compositing-合成">compositing 合成</h3><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/compositing.gif" alt="Apr-25-2019_23-01-04"/></p><p>compositing 则是将 page 分成不同的 layer, 对每个 layer 都进行 raster(光栅化)，然后在  <em>compositor thread</em> 上合成(composition).
页面滚动时因为 layer 都已经 raster 完成，只需要合成。</p><p>composition 会根据 Layout tree, 构建一棵 layer tree。不是一个Element 一个layer, 具体如下 <a class=" " href="https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count">Stick to Compositor-Only Properties and Manage Layer Count</a></p><blockquote><p>compositing 不在 main thread 上完成，不需要等待  style 计算、js 执行.</p></blockquote><h3 id="css-对各个阶段的影响">CSS 对各个阶段的影响</h3><p>详情见： <a class=" " href="https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/</a></p><ul><li>transform 与 opacity 会在compositor thread 中处理，不会影响主线程。</li><li>回流(reflows) 影响了 layout，重绘(repaint) 影响了 paint 过程</li></ul><p>如何减少回流与重绘：
<a class=" " href="https://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/">ZXX 回流与重绘</a></p><h2 id="参考文献">参考文献</h2><ul><li><a class=" " href="https://developers.google.com/web/updates/2018/09/inside-browser-part1">本文英文原文</a> </li><li><a class=" " href="https://blog.logrocket.com/eliminate-content-repaints-with-the-new-layers-panel-in-chrome-e2c306d4d752">eliminate-content-repaints-with-the-new-layers-panel</a></li><li><a class=" " href="https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">high-performance-animations</a></li><li><a class=" " href="https://www.html5rocks.com/zh/tutorials/speed/layers/">Accelerated Rendering in Chrome</a></li></ul></div><footer class="BlogPostLayout_footer__3wanu"><h3 class="BlogPostLayout_title__r71Bd"><a class=" " href="/">qingtong Blog</a></h3><div class="
      Bio_Bio__3-4kF
      BlogPostLayout_bio___cslQ
    "><img src="https://www.gravatar.com/avatar/aa99b351245441b8ca95d54a52d2998c.jpg?s=56&amp;d=identicon" alt="Me"/><p>来自接地气的一线实践开发经验，用心做原创<br/>分享关于 React、数据可视化、效率工具等，打造专业前端知识库</p></div><section class="BlogPostLayout_links__nRwfs"><a class=" " href="/posts/2019-08-01/typescript-redux/">← <!-- -->大型项目 typescript + redux 实践</a><a class="BlogPostLayout_next__Yy9RW " href="/posts/2018-12-28/react-element/">React 类型探究<!-- --> →</a></section></footer></article></main></div></div><script>!function(u){function e(e){for(var t,r,n=e[0],o=e[1],a=e[2],c=0,f=[];c<n.length;c++)r=n[c],l[r]&&f.push(l[r][0]),l[r]=0;for(t in o)Object.prototype.hasOwnProperty.call(o,t)&&(u[t]=o[t]);for(p&&p(e);f.length;)f.shift()();return d.push.apply(d,a||[]),i()}function i(){for(var e,t=0;t<d.length;t++){for(var r=d[t],n=!0,o=1;o<r.length;o++){var a=r[o];0!==l[a]&&(n=!1)}n&&(d.splice(t--,1),e=s(s.s=r[0]))}return e}var r={},f={21:0},l={21:0},d=[];function s(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return u[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.e=function(d){var e=[];f[d]?e.push(f[d]):0!==f[d]&&{1:1,11:1,18:1}[d]&&e.push(f[d]=new Promise(function(e,n){for(var t="static/css/"+({}[d]||d)+"."+{1:"e905a530",2:"31d6cfe0",3:"31d6cfe0",4:"31d6cfe0",5:"31d6cfe0",6:"31d6cfe0",7:"31d6cfe0",8:"31d6cfe0",9:"31d6cfe0",10:"31d6cfe0",11:"3f702457",12:"31d6cfe0",13:"31d6cfe0",14:"31d6cfe0",15:"31d6cfe0",16:"31d6cfe0",17:"31d6cfe0",18:"6ad57d2f",19:"31d6cfe0"}[d]+".chunk.css",o=s.p+t,r=document.getElementsByTagName("link"),a=0;a<r.length;a++){var c=(u=r[a]).getAttribute("data-href")||u.getAttribute("href");if("stylesheet"===u.rel&&(c===t||c===o))return e()}var f=document.getElementsByTagName("style");for(a=0;a<f.length;a++){var u;if((c=(u=f[a]).getAttribute("data-href"))===t||c===o)return e()}var i=document.createElement("link");i.rel="stylesheet",i.type="text/css",i.onload=e,i.onerror=function(e){var t=e&&e.target&&e.target.src||o,r=new Error("Loading CSS chunk "+d+" failed.\n("+t+")");r.request=t,n(r)},i.href=o,document.getElementsByTagName("head")[0].appendChild(i)}).then(function(){f[d]=0}));var r=l[d];if(0!==r)if(r)e.push(r[2]);else{var t=new Promise(function(e,t){r=l[d]=[e,t]});e.push(r[2]=t);var n,o=document.getElementsByTagName("head")[0],a=document.createElement("script");a.charset="utf-8",a.timeout=120,s.nc&&a.setAttribute("nonce",s.nc),a.src=s.p+"static/js/"+({}[d]||d)+"."+{1:"9505c71e",2:"09ae3736",3:"37128771",4:"f63f5055",5:"b19583a2",6:"5cac06ef",7:"1d89cedb",8:"7e490174",9:"a95af001",10:"ee04876c",11:"74983fd6",12:"2dc8ce2a",13:"f6f2b928",14:"01406494",15:"1bb9838f",16:"db01a2a8",17:"209448f4",18:"d026322e",19:"604f6b68"}[d]+".chunk.js",n=function(e){a.onerror=a.onload=null,clearTimeout(c);var t=l[d];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),n=e&&e.target&&e.target.src,o=new Error("Loading chunk "+d+" failed.\n("+r+": "+n+")");o.type=r,o.request=n,t[1](o)}l[d]=void 0}};var c=setTimeout(function(){n({type:"timeout",target:a})},12e4);a.onerror=a.onload=n,o.appendChild(a)}return Promise.all(e)},s.m=u,s.c=r,s.d=function(e,t,r){s.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(t,e){if(1&e&&(t=s(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(s.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)s.d(r,n,function(e){return t[e]}.bind(null,n));return r},s.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(t,"a",t),t},s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},s.p="/blog/",s.oe=function(e){throw console.error(e),e};var t=window.webpackJsonp=window.webpackJsonp||[],n=t.push.bind(t);t.push=e,t=t.slice();for(var o=0;o<t.length;o++)e(t[o]);var p=n;i()}([])</script><script src="/blog/static/js/20.84d39ba6.chunk.js"></script><script src="/blog/static/js/main.bcb7d206.chunk.js"></script></body></html>