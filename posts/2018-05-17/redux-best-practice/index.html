<!doctype html><html lang="en"><head><meta charset="utf-8"><link rel="shortcut icon" href="/blog/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="theme-color" content="#000000"><link rel="manifest" href="/blog/manifest.json"><link rel="canonical" href="/blog/posts/2018-05-17/redux-best-practice/" />

    <title data-react-helmet="true">redux 最佳实践</title>
    
    
  <link rel="stylesheet" href="/blog/static/css/1.7e9e0c37.chunk.css" /><link href="/blog/static/css/main.d6f6a394.chunk.css" rel="stylesheet"></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div id="root"><div class="BlogLayout_container__2z5VE"><div class="
        LoadingIndicator_LoadingIndicator__LI6x0
        
        undefined
      "></div><header><h3 class="BlogLayout_title__nZ4wJ"><a class=" " href="/">qingtong Blog</a></h3></header><main><article><header class="BlogPostLayout_header__hNrNi"><h1 class="BlogPostLayout_title__j9S_E"><a class=" " href="/posts/2018-05-17/redux-best-practice/">redux 最佳实践</a></h1><small><time dateTime="Wed, 16 May 2018 16:00:00 GMT">May 17, 2018</time> <!-- -->•<!-- --> <ul class="ArticleMeta_tags__bwcp_"><li><a class=" " href="/tags/redux/">redux</a></li></ul> <!-- -->•<!-- --> <span>☕️<!-- --> <!-- -->4<!-- --> min read</span></small></header><div class="BlogPostLayout_content__3oTIu"><h2 id="1-什么时候才需要引入-redux-？">1. 什么时候才需要引入 redux ？</h2><p>  <img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2018-05-17-redux-best-practice/image/redux-pipeline.png" alt="redux-pipeline"/></p><p>  redux 的作者写过一篇文章，<a class=" " href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367">你也许不需要redux</a>，当你开发一个简单应用的时候，redux 不应该成为你的首选。相反，redux 约定了一套基础规范来约束开发：</p><ul><li><p>用对象来描述应用状态 「store」</p></li><li><p>用对象来描述应用中的状态变化 「action」</p></li><li><p>用纯函数来描述处理状态变更的逻辑  <!-- -->[reducer]</p><p>那么，应用 redux 能够给我们带来的好处在于：</p></li><li><p>持久化状态数据</p></li><li><p>ssr</p></li><li><p>实现undo、redo操作</p></li><li><p>应用状态的时间旅行管理</p></li><li><p>多用户协同开发</p></li><li><p>开发工具扩展能力</p></li><li><p>强大的组合能力</p></li></ul><p>redux 提供的是一套全局的状态管理能力，如果你当前组件只需要本地 state 就能维护好应用状态，就没有必要引入 redux。只有当我们面临着以下场景：</p><ul><li>某个组件的状态，需要共享</li><li>某个状态需要在任何地方都可以拿到</li><li>一个组件需要改变全局状态</li><li>一个组件需要改变另一个组件的状态</li></ul><p>redux 提供的解决方案就能有效地帮助我们管理数据的复杂性。</p><h2 id="2-学习-redux-之前的预备知识？">2. 学习 redux 之前的预备知识？</h2><ul><li>react 应用 state 和 props 进行应用管理</li><li>react 中应用 HOC 进行代码抽象和复用</li><li>Context 全局对象</li><li>Smart、 Dumb组件</li><li>具体见<a class=" " href="https://reactjs.org/docs/hello-world.html">官网文档</a></li></ul><h2 id="3-redux-的基础知识">3. redux 的基础知识</h2><ul><li><p><a class=" " href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html">1. Redux 入门教程</a></p></li><li><p><a class=" " href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">2. 中间件与异步操作</a></p></li><li><p><a class=" " href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html">3. react-redux</a></p></li></ul><h2 id="4-redux-数据结构">4. redux 数据结构</h2><p>  经常遇到的一个问题是：</p><p>  <strong>什么时候使用 Redux store，什么时候使用 React state？</strong></p><p>  <img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2018-05-17-redux-best-practice/image/redux_state.png" alt="redux_state"/></p><p>  <a class=" " href="https://redux.js.org/faq/organizing-state#organizing-state-only-redux-state">redux 官方文档给出的回答</a>是：</p><ul><li><p>如果明确状态变更只会影响当前组件，类似于按钮状态，输入框状态，内部数据联动展示、弹窗展示等，都建议放到 state 里面进行管理</p></li><li><p>当以下场景回答为“是”时，redux store 就是更好的选择：</p><ul><li>应用中的其他部分需要用到这部分数据吗？</li><li>是否需要根据这部分原始数据创建衍生数据？</li><li>这部分相同的数据是否用于驱动多个组件？</li><li>你是否需要能够将数据恢复到某个特定的时间点（比如：在时间旅行调试的时候）？</li><li>是否需要缓存数据？（比如：直接使用已经存在的数据，而不是重新请求）</li></ul><p>实际上，我们需要一套更通用的方案来指导如何架构redux store。按照我们的实际开发经验来看，可以将数据分为<code>ui状态</code>和<code>数据逻辑</code>:</p></li></ul><h3 id="ui状态">ui状态</h3><p>  可以包括<code>弹窗展示</code>、<code>tab切换</code>，<code>下拉菜单</code>等不涉及数据逻辑的状态，通常这些更适合放在<code>React state</code>管理。</p><h3 id="数据逻辑">数据逻辑</h3><p> 我们可以通过<strong>数据持久度</strong>和<strong>数据消费程度</strong>来区分数据类型：</p><h4 id="数据持久度">数据持久度</h4><ul><li>快速变更型</li><li>中等持续型</li><li>长远稳定型</li></ul><p> <strong>快速变更型</strong>，这类数据往往代表着短时间内快速变更，比如文本框内容可能随着用户输入持续变化，或者快速拖动变更位置等，这类数据更加适合维护在state中。</p><p> <strong>中等持续性</strong>，当用户浏览或者使用应用时，在刷新页面之前数据保持相对稳定，比如ajax获取数据，编辑form表单等，这类数据比较通用，可能被其他组件所应用。这类数据适合通过redux store维护，再通过connect被组件使用。</p><p> <strong>长远稳定型</strong>，指在页面多次刷新或者多次访问期间都保持不变的数据，这类数据通常不会放在redux里面维护，一般会放到localstorage或者db里面。</p><h4 id="数据消费程度">数据消费程度</h4><p>  数据特性体现在消费层面，即有多少组件需要使用。越多组件消费的数据，就应该放在 redux store 里面维护，反之，当数据只服务于单一组件时，由 React State 维护就更加合理。</p><p>  <strong>最后，什么情况该使用哪种数据管理方式，是 React 维护 state 还是 Redux 集中管理，这个讨论不会有唯一定论。这需要开发者对于 React，Redux 深入理解，并结合场景需求完成选择。</strong></p><h2 id="5-fsa-设计规范">5. FSA 设计规范</h2><p>redux 设计非常精简，并没有追求大而全。在具体实践上，官方并没有约定一套通用的标准，在开发社区里面有很多的约定方案，其中最广为接受的方案就是<a class=" " href="https://github.com/redux-utilities/flux-standard-action">FSA</a>，全称是 <code>flux-standard-action</code>。</p><p><code>FSA</code> 的设计理念在于规范 <code>action</code> 的标准写法，让开发者都遵循同一套规范，简单友好可依赖。具体的标准如下：</p><ul><li><code>action</code> 是一个纯对象</li><li>必须要有 <code>type</code> 字段，来表示 action 类型</li><li>至少要有 <code>error</code>，<code>payload</code>, <code>meta</code> 属性之一</li><li>若 <code>action</code> 报错，<code>error</code> 必须为 true</li><li>不能有<code>type</code>, <code>error</code>，<code>payload</code>, <code>meta</code> 之外的其他属性 </li></ul><h3 id="type">type</h3><p>[必选]<!-- --> <code>type</code> 属性必须是字符串类型常量，通过 <code>type</code> 可以将 <code>action</code> 和 <code>reducer</code> 串联起来。</p><h3 id="payload">payload</h3><p>[可选]<!-- --> payload 代表 action 存放的内容，可以是任意类型的数据。当<code>error</code>值为 true 时，此时 payload 应当是一个 Error 对象</p><h3 id="error">error</h3><p>[可选]<!-- --> error 当取值为 true 时，此时 action 发生了错误</p><h3 id="meta">meta</h3><p>[可选]<!-- --> action 的额外信息，典型使用场景就是当 action payload 是一个 promise 时，通过 meta 来传递相应参数。</p><p>正式基于相同的 action 架构，<code>redux-actions</code>，<code>redux-promise-middle</code> 都是基于 <code>FSA</code> 架构的 action 处理工具。</p><h2 id="6-redux-store-设计">6. redux store 设计</h2><p>redux Store 是整个应用的核心，决定了应用如何渲染，渲染的结果是什么。所以设计好 redux store 是重中之重。</p><p>在设计 redux store 之前，我们先聊一下应用的架构。说到底，store 设计是需要服务应用架构的，离开项目需求单独讨论 store 是无本之木。</p><p>目前信贷中后台页面都是基于 papaya 的单页架构，单页架构又分为两种：</p><ul><li>A：每个页面都是一个独立的模块，页面切换会刷新当前页面，页面之间不需要共享全局状态（流程引擎）</li><li>B：纯粹单页应用，多个模块共同组成一个页面，模块切换不会刷新当前页面，需要共享全局状态（机器学习）</li></ul><p>这两类应用所维护的 store 架构就需要分开设计。</p><p><strong>从横向来看</strong>，「A应用」就适合于按「Page 页面」进行分类，也不需要抽取共享状态用于页面间分享：</p><pre><code>- page1
  - module1
  - module2
  - module3
- page2
</code></pre><p>「B应用」更适合于按照「Feature 功能」进行分类，模块之间需要抽象出全局共享状态：</p><pre><code>- app（全局共享状态）
- routing（路由数据）
- module1
- module2
</code></pre><p><strong>从纵向来看</strong>，store 设计通用设计可以参考：</p><ul><li>store 设计尽量扁平化，store 里面 state 结构不要超过 3 层，数据之间可以通过 <code>id</code> 进行连接</li><li>多个模块之间需要共享的数据，放到父模块存储</li></ul><h2 id="7-reducer-设计">7. reducer 设计</h2><p>redux 官方示范给的 reducer 写法：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">function</span> <span class="token function">todos</span><span class="token punctuation">(</span><span class="token parameter">state <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token constant">ADD_TODO</span><span class="token operator">:</span>
      <span class="token comment">// return state1</span>
    <span class="token keyword">case</span> <span class="token constant">TOGGLE_TODO</span><span class="token operator">:</span>
      <span class="token comment">// return state2</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">return</span> state
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>这种写法很好，但是不够精简，我们完全可以代替以 对象 写法：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">import</span> typeToReducer <span class="token keyword">from</span> <span class="token string">'type-to-reducer'</span>

<span class="token keyword">const</span> todosReducer <span class="token operator">=</span> <span class="token function">typeToReducer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">ADD_TODO</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>state1<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token constant">TOGGLE_TODO</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>state2<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><p>不仅代码更加精简，语义性也变得更强了，并且还减少了维护成本，一举三得。</p><h2 id="8-redux-actions">8. redux actions</h2><p>基于 <code>FSA</code> 架构，我们可以产出两套<code>action</code> 方案：</p><h3 id="actioncreator-写法">actionCreator 写法</h3><p><code>actionCreator</code> 写法接近于原生 action 写法:</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token comment">// 一个标准的actionCreator 同步写法</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">setWorkSpaceRectData</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    type<span class="token operator">:</span> types<span class="token punctuation">.</span><span class="token constant">SET_WORKSPACE_RECT_DATA</span><span class="token punctuation">,</span>
    payload<span class="token operator">:</span> <span class="token punctuation">{</span>value<span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token comment">// 一个标准的actionCreator 异步写法</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">queryAppList</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">userName</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    type<span class="token operator">:</span> types<span class="token punctuation">.</span><span class="token constant">QUERY_APP_LIST</span><span class="token punctuation">,</span>
    payload<span class="token operator">:</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/serving/users/apps</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    meta<span class="token operator">:</span> userName
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="redux-action-写法">redux-action 写法</h3><p>社区提供另外一个简化action写法的解决方案，<a class=" " href="https://github.com/redux-utilities/redux-actions">redux-actions</a>，基于 redux-actions 对上述 action 做下改造：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">import</span> <span class="token punctuation">{</span> createAction <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux-actions'</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> setWorkSpaceRectData <span class="token operator">=</span> <span class="token function">createAction</span><span class="token punctuation">(</span>
  types<span class="token punctuation">.</span><span class="token constant">SET_WORKSPACE_RECT_DATA</span><span class="token punctuation">,</span>
  <span class="token parameter">value</span> <span class="token operator">=></span> <span class="token punctuation">{</span>value<span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> queryAppList <span class="token operator">=</span> <span class="token function">createAction</span><span class="token punctuation">(</span>
  types<span class="token punctuation">.</span><span class="token constant">QUERY_APP_LIST</span><span class="token punctuation">,</span>
  <span class="token parameter">userName</span> <span class="token operator">=></span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/serving/users/apps</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token parameter">userName</span> <span class="token operator">=></span> userName
<span class="token punctuation">)</span>
</code></pre><p>个人还是偏向原生写法，redux-action 将 action 属性封装以后反而加大了理解难度。</p><h2 id="9-redux-中间件">9. redux 中间件</h2><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016092002.jpg" alt="redux-middleware"/></p><p>redux 的中间件模型类似于 koa 的洋葱模型，对<code>store.dispatch</code>方法进行改造，就可以添加功能，具体原理参考<a class=" " href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">2. 中间件与异步操作</a>。这里只是推荐一些常用的中间件。</p><h3 id="91-redux-thunk">9.1 redux-thunk</h3><p>redux 原生设计只支持同步 Action，redux-thunk 的原理是 action 进行拦截判断，如果 thunk 发现 action 类型是函数，就在action 回调里面再触发 action，这也是 redux 异步方案的通用解决方案。</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">const</span> <span class="token function-variable function">getDataAction</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1. 这里 生成的action 是一个函数，通过thunk 包装以后，实际触发的action 是 action 2</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">dispatch<span class="token punctuation">,</span> getState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 2. 这里才是真正触发的action</span>
    <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      type<span class="token operator">:</span> <span class="token constant">GET_DATA</span><span class="token punctuation">,</span> 
      payload<span class="token operator">:</span> id
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">getDataAction</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><h3 id="92-redux-promise-middleware">9.2 redux-promise-middleware</h3><p>redux-thunk 能够实现异步action，但是无法实现异步 action 的串联</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token function">action1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">action2</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>并且<code>redux-thunk</code>写法非常冗余，需要针对异步action 手工添加状态信息，<code>redux-promise-middleware</code> 则会自动生成
<code>actionType_${status}</code>的 type 类型，结合<a class=" " href="https://github.com/tomatau/type-to-reducer">type-to-reducer</a>就能实现很好地代码优化。</p><h3 id="93-redux-logger">9.3 redux-logger</h3><p>redux-logger 能够将 action 打印到控制台，非常方便 debug。</p><h3 id="94-redux-devtools-extension">9.4 redux-devtools-extension</h3><p>redux 作者维护的结合浏览器插件的开发神器。</p><h2 id="qa">QA</h2><p>1 是否允许按需 connect？</p><blockquote><p>允许。具体还是从业务层面需求出发，如果当前组件我们认为其更加适合作为一个容器型组件，也就是跟业务数据有很强的关联，这个时候connect 就是比较好的选择，反之，如果当前组件更偏向于展示型，那么数据来源更合适从父组件获取，而非 connect。</p><p>关于何时 connect 比较合适，目前无法提供一套通用的解决方案，还是需要从实际业务中去判断，一个原则是 当需要跟业务数据强关联，就合适 connect，反之如果组件更适合作为展示组件，就更适合从父组件上获取数据。</p></blockquote><p>2 目录结构划分，是按照action，reducer，constant 按功能进行页面区分，还是支持像 <a class=" " href="https://github.com/erikras/ducks-modular-redux">ducks</a> 将所有文件统一管理？</p><blockquote><p><a class=" " href="https://github.com/erikras/ducks-modular-redux">ducks</a>写法推崇将 actionCreator，reducer，constant 都写到同一个文件里，优点在于减少页面切换。但 redux 作者并不赞同，因为这种写法会给用户造成 action 和 reducer 是一一对应的错误，并且当 action 需要共享 reducer 时，无法做到抽象。</p><p><strong>结论</strong>，优先推荐使用 ducks 写法，如果有复杂数据处理场景，建议采用按功能区分的写法。</p></blockquote><p>3 immutable 在哪里 toJS？</p><blockquote><p>immutable 在 connect 里面 toJS 是一种反模式，并且在展示组件（Dumb）里面是否应用 immutable 对象，<a class=" " href="https://redux.js.org/recipes/using-immutable.js-with-redux#never-use-immutable-js-in-your-dumb-components">官方并不推荐</a>，实际上如果组件之间传递的是 immutable 对象对性能提升有一定的帮助。</p><p><strong>结论</strong>，toJS 建议按需来转，比如当跟服务端进行数据交互时就应该执行 toJS 操作。另外，展示组件 推荐传递非 immutalble 对象，当需要性能优化时，可以考虑传递 immutable 对象</p></blockquote><p>4 一个 action 是否需要聚合所有操作？</p><blockquote><p>action 聚合最合适的时候应该交由 view 层控制，每个 action 维护的都是最小单元的数据操作逻辑。通过<code>redux-promise-middleware</code> 可以实现 异步action 串联和聚合效果。</p><p>另外，即使这种情况下，因为无法保证所有 action 都能返回 promise，所以<strong>不建议移除 redux-thunk</strong>。</p></blockquote><p>5 目前在papaya 中使用的 FSA、 type-to-reducer、ducks 这种是否为强制规范？</p><blockquote><p>FSA 是目前 redux 社区推荐的方案，建议使用，type-to-reducer 能够帮助书写更优雅的reducer，并且是对 redux-promise-middleware 的优化写法，ducks 可以减少文件维护成本。</p><p><strong>结论</strong>，推荐使用FSA、type-to-reducer、ducks 等写法。</p></blockquote><p>6 哪种情况数据应该放在 state 中，哪种应该放在 store 中？</p><blockquote><p>参考 <!-- -->[redux数据结构]<!-- -->(#4. redux 数据结构)</p></blockquote><p>7 什么情况下使用 action , 什么情况下使用静态方法？</p><blockquote><p>如果涉及到后端请求或前端查询数据，即使不用关心action操作返回的值，也建议使用action，因为后续如果需求改动或者数据变更，有更好的可扩展性。静态方法适合于跟数据逻辑无关的 ui 状态。</p></blockquote><p>8 如何组织一个前端业务操作流，例如：执行了发货操作，操作成功，执行查询操作，再执行 xxx 操作。。。</p><blockquote><p>在 React 层来调用相应 action：</p></blockquote><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">mail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res2</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
        <span class="token comment">// something else</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>9 promiseMiddleware 的最佳实践和反模式？</p><blockquote><p><a class=" " href="https://github.com/pburtchaell/redux-promise-middleware/tree/master/docs/guides">官方文档</a></p></blockquote></div><footer class="BlogPostLayout_footer__1TyyS"><h3 class="BlogPostLayout_title__j9S_E"><a class=" " href="/">qingtong Blog</a></h3><div class="
      Bio_Bio__iDVYA
      BlogPostLayout_bio__2WXr0
    "><img src="https://www.gravatar.com/avatar/aa99b351245441b8ca95d54a52d2998c.jpg?s=56&amp;d=identicon" alt="Me"/><p>来自接地气的一线实践开发经验，用心做原创<br/>分享关于 React、数据可视化、效率工具等，打造专业前端知识库</p></div><section class="BlogPostLayout_links__1fL9M"><a class=" " href="/posts/2018-08-15/you-dont-know-react/">← <!-- -->React 你不知道的那些事儿</a></section></footer></article></main></div></div><script>!function(f){function e(e){for(var t,r,n=e[0],o=e[1],a=e[2],c=0,u=[];c<n.length;c++)r=n[c],d[r]&&u.push(d[r][0]),d[r]=0;for(t in o)Object.prototype.hasOwnProperty.call(o,t)&&(f[t]=o[t]);for(p&&p(e);u.length;)u.shift()();return l.push.apply(l,a||[]),i()}function i(){for(var e,t=0;t<l.length;t++){for(var r=l[t],n=!0,o=1;o<r.length;o++){var a=r[o];0!==d[a]&&(n=!1)}n&&(l.splice(t--,1),e=s(s.s=r[0]))}return e}var r={},u={19:0},d={19:0},l=[];function s(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return f[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.e=function(l){var e=[];u[l]?e.push(u[l]):0!==u[l]&&{1:1,10:1,17:1}[l]&&e.push(u[l]=new Promise(function(e,n){for(var t="static/css/"+({}[l]||l)+"."+{1:"7e9e0c37",2:"31d6cfe0",3:"31d6cfe0",4:"31d6cfe0",5:"31d6cfe0",6:"31d6cfe0",7:"31d6cfe0",8:"31d6cfe0",9:"31d6cfe0",10:"17ee5b7e",11:"31d6cfe0",12:"31d6cfe0",13:"31d6cfe0",14:"31d6cfe0",15:"31d6cfe0",16:"31d6cfe0",17:"b0f02a97"}[l]+".chunk.css",o=s.p+t,r=document.getElementsByTagName("link"),a=0;a<r.length;a++){var c=(f=r[a]).getAttribute("data-href")||f.getAttribute("href");if("stylesheet"===f.rel&&(c===t||c===o))return e()}var u=document.getElementsByTagName("style");for(a=0;a<u.length;a++){var f;if((c=(f=u[a]).getAttribute("data-href"))===t||c===o)return e()}var i=document.createElement("link");i.rel="stylesheet",i.type="text/css",i.onload=e,i.onerror=function(e){var t=e&&e.target&&e.target.src||o,r=new Error("Loading CSS chunk "+l+" failed.\n("+t+")");r.request=t,n(r)},i.href=o,document.getElementsByTagName("head")[0].appendChild(i)}).then(function(){u[l]=0}));var r=d[l];if(0!==r)if(r)e.push(r[2]);else{var t=new Promise(function(e,t){r=d[l]=[e,t]});e.push(r[2]=t);var n,o=document.getElementsByTagName("head")[0],a=document.createElement("script");a.charset="utf-8",a.timeout=120,s.nc&&a.setAttribute("nonce",s.nc),a.src=s.p+"static/js/"+({}[l]||l)+"."+{1:"c2cb174b",2:"6b76d4c7",3:"91d9b728",4:"418e8258",5:"1817cc94",6:"c5258100",7:"c0f1f6a4",8:"696a923b",9:"22a94885",10:"99d28899",11:"71b25eb2",12:"cb1159b5",13:"d97a73e2",14:"e74afb6e",15:"8acd376e",16:"da680be3",17:"43db5ace"}[l]+".chunk.js",n=function(e){a.onerror=a.onload=null,clearTimeout(c);var t=d[l];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),n=e&&e.target&&e.target.src,o=new Error("Loading chunk "+l+" failed.\n("+r+": "+n+")");o.type=r,o.request=n,t[1](o)}d[l]=void 0}};var c=setTimeout(function(){n({type:"timeout",target:a})},12e4);a.onerror=a.onload=n,o.appendChild(a)}return Promise.all(e)},s.m=f,s.c=r,s.d=function(e,t,r){s.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(t,e){if(1&e&&(t=s(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(s.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var n in t)s.d(r,n,function(e){return t[e]}.bind(null,n));return r},s.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(t,"a",t),t},s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},s.p="/blog/",s.oe=function(e){throw console.error(e),e};var t=window.webpackJsonp=window.webpackJsonp||[],n=t.push.bind(t);t.push=e,t=t.slice();for(var o=0;o<t.length;o++)e(t[o]);var p=n;i()}([])</script><script src="/blog/static/js/18.3029b03e.chunk.js"></script><script src="/blog/static/js/main.b1df4670.chunk.js"></script></body></html>