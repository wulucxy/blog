### 背景

Framework 会作为 [harley 微前端方案](http://git.caimi-inc.com/trinity/discussions/issues/653) 的一些基础能力，包括 `Route 路由`, `Layout 布局`，`Event 事件`, `RootDecorator 子应用装饰器`等，同时在 Framework 开发中提供一些基础设施能力。


### 整体架构

![image](http://git.caimi-inc.com/trinity/discussions/uploads/b33bc29c26c8c60f3d4e16d1c31b6d22/image.png)

### 配置信息

全局配置由以下几部分组成：

- 菜单信息
  - mode: `basic` | `header` | `sider` | `blank`
  - list: 参考下方菜单示例
- logo
- pageTitle
- logoutUrl

<details>
<summary>详细菜单信息</summary>

```json
[
  {
    "icon": "home", // icon
    "id": 115822,  // 唯一 id
    "title": "harkey", // 标题
    "path": "/",   // 一级路由
    "children": null, // 子应用
  },
  {
    "icon": "user",
    "id": 115812,
    "title": "技术栈",
    "path": "/stack",
    "children": [
      {
        "id": 115817,
        "title": "react",
        "config": {
          "path": "/react",  // 子应用路径
          "entry": "/localhost:7100", // 子应用入口
          "name": 'react' // 子应用名称
          "props": { // 自定义属性
            "aa": "aa",
            "bb": "bb"     
          }
        }
        "children": null,
      },
      {
        "id": 115833,
        "title": vue",
        "config": {
          "path": "/vue",
          "entry": "/localhost:7200",
          "name": 'vue'
        }
        "children": null,
      },
    ],
  },
  {
    "icon": "appstore-o",
    "id": 115821,
    "title": "框架",
    "path": "/framework",
    "children": [
      {
        "id": 115833,
        "title": "qiankun",
        "config": {
          "path": "/qiankun",
          "entry": "/localhost:7300",
          "name": 'qiankun'
        }
        "children": [],
      },
      {
        "id": 115839,
        "title": "single-spa",
        "config": {
          "path": "/single-spa",
          "entry": "http://uwdc.activity.k2.test.wacai.info/uwdc/batch",
          "name": 'single-spa'
        }
        "children": null,
      }
    ],
  },
]
```
</details>


### 路由

`Framework` 会托管主应用路由管理，并通过 `dynamic import` 的方式，从配置中心提供的配置异步加载子应用。

简单描述：

```javascript
// 主应用入口
const MainApp = ({menu, pageTitle, logo, logoutUrl}) => {
  useEffect(() => {
    // 加载子应用
    bootstrap(menus)
  }, [])

  // 渲染主体框架
  return (
    <ConfigProvider value={routerContext}>
      <Router>
        <Route path = '/'>
          <Layout menu={menu} pageTitle={pageTitle} logo={logo} logoutUrl={logoutUrl} />
        </Route>
      </Router>
    </ConfigProvider>
  )
}

/**
 * bootstrap: 子应用加载逻辑处理
 */

// 1. 注册子应用
const microConfig = (menus) => menus.map(menu => ({
  name, // 子应用名称
  activeUrl, // 子应用规则
  entry, // 入口
  render: renderMicroApp, // 子应用渲染逻辑
  props // 自定义属性
}))


// 2. 子应用渲染逻辑
const renderMicroApp = ({appContent, loading}) => {
  ReactDom.render(<ContainerApp appContent={appContent} loading={loading} />)
}

const ContainerApp = ({loading, appContent}) => {
  return (
    <div>
      {loading ? <div>loading...</div> : null}
      <div dangerouslySetInnerHTML={{ __html: content }} className={style.appContainer} />
    </div>
  )
}

//  3. 加载子应用
registerMicroApps(microConfig);
start();
```


### Layout

`Layout` 会作为主、子应用的布局容器，由主应用负责应用的加载，并且管理左侧和顶部的导航栏，子应用则展示在右侧区域，如下图所示：

![image](http://git.caimi-inc.com/trinity/discussions/uploads/c51f0f8afd4fb63be9b9a03211db1f7b/image.png)

Layout 目前考虑提供以下能力：

- 基于配置的菜单自动生成顶部导航和左侧导航
- Header 全局信息展示（租户管理、帮助文档，logo等）
- 全局状态（用户信息、active、theme 等）
- 面包屑导航能力
- 公共 footer


#### 2. Header

参考 papaya 实现，提供自定义组件挂载

#### 3. 全局状态

通过 `React.Context` 保留全局信息：

- useInfo
  - name
  - role
- routeInfo
  - active: ['mainMenuId', 'subMenuId']
  - menuList：菜单列表
- customInfo
  - 租户信息
  - 主题
  - 其他自定义全局变量

#### 4. 面包屑

通过 `routeInfo` 自动生成

#### 5. footer

 没什么好说的
 
 
### Event
 
 Event 模块会收拢全局的事件处理能力，本质上是封装了`window.dispatchEvent` ，让子应用之前通过事件机制进行通信。
 
 ```javascript
 // App1: 发起事件
 eventBus.dispatch(name, payload)
 ```
 
 ```javascript
 // App2: 订阅事件，返回一个订阅者
 const subscriber = eventBus.subscribe(name, callback: payload => void)
 
// 取消订阅
subscriber.unSubscribe(name)
 ```
 
 ![image](http://git.caimi-inc.com/trinity/discussions/uploads/fc199d8fafa1e30db07466aa82cb87a0/image.png)

 
### RootDecorator
  
 `RootDecorator` 用来装饰子应用，提供一些公共能力来增强子应用。
 
 - ErrorBoundary
 
 应用之间的错误必需隔离，一旦应用错误冒泡到主应用，会导致整个框架崩溃。`RootDecorator` 会基于 `react` 提供一个公共的 `ErrorBoundary` 装饰器。 
 
 ```javascript
 export default RootDecorator({
  moduleName: '@wac/some-app'
 })(App)
 ```
 
> ErrorBoundary 是 react 16 以后才开放能力。暂时不考虑其他技术栈。
> 已有项目自身的根组件 ErrorBounrady 需要移除
  

### 其他

#### 应用隔离

目前 qiankun 已经内置实现了子应用之间 `js` 和 `css` 隔离，我们剩下要做的就是实现**主应用和子应用隔离**。

相遇子应用之间的隔离问题，主、子应用隔离就简单很多了，因为**主应用是可防可控可收敛的**。

**js 隔离**

一方面借助打包工具可以避免大部分的全局冲突，因为大多数代码都被编译成了闭包、和内部方法。余下的一部分完全可以通过约定的方式避免冲突：这些规范包括但不限于：尽量不挂载会引起副作用的全局变量、收敛不可控的三方包等等。

**css 隔离**

css 隔离我们可以遵循 BFC 的思想，通过统一的 `namespace` 或者 `css mudule` 的方式，给每个模块添加业务前缀，即可保证不会互相干扰。我们采用的方式是添加 `namespace` 方案。

#### 配置中心

在一个微前端体系下，如何去管理主应用与子应用之间的依赖关系，或者去获取对应的用户权限，怎么监控子应用的运行状态？

我们可以在前端层面实现应用之间的分离和聚合，但如何去保证框架的平稳运行、可防可控，我们还是需要一套配套的管理后台，也就是微服务配置中心。我们需要实现的能力包括：

- 应用基本信息
- 应用的访问权限
- 应用的关联信息

此处参考网易严选微服务后台：

![网易严选微服务后台](http://git.caimi-inc.com/trinity/discussions/uploads/920a9e4f37efbc6800d126299a787b4c/image.png)

如果说主框架让我们从技术上实现了微前端，那么 相关配套设施则是在具体的业务场景中落地的点睛之笔。

### 输出工具类

- navagateToUrl：路由跳转方法
- 统一的错误处理机制

### 开发规范

- typescript + lerna
- 打包输出支持 esm, commonjs 和 umd 格式

### 参考文档

- [微前端的设计理念与实践初探](https://zhuanlan.zhihu.com/p/41879781)
- [网易严选企业级微前端解决方案与落地实践](https://zhuanlan.zhihu.com/p/97226980)