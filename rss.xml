<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>qingtong Blog</title>
        <link>/blog</link>
        <description>来自前端一线开发的实践分享，用心做原创</description>
        <lastBuildDate>Sun, 30 Jul 2023 08:23:20 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[redux 最佳实践]]></title>
            <link>/blog/posts/2018-05-17/redux-best-practice/</link>
            <guid>/blog/posts/2018-05-17/redux-best-practice/</guid>
            <content:encoded><![CDATA[<div><p><strong>2020–03–09 更新：<a href="https://wulucxy.github.io/redux-typescript-guide/">typescript + redux 实战 demo</a></strong></p><h2 id="1-什么时候才需要引入-redux-">1. 什么时候才需要引入 redux ？</h2><p>  <img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2018-05-17-redux-best-practice/image/redux-pipeline.png" alt="redux-pipeline"/></p><p>  redux 的作者写过一篇文章，<a href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367">你也许不需要redux</a>，当你开发一个简单应用的时候，redux 不应该成为你的首选。相反，redux 约定了一套基础规范来约束开发：</p><ul><li><p>用对象来描述应用状态 「store」</p></li><li><p>用对象来描述应用中的状态变化 「action」</p></li><li><p>用纯函数来描述处理状态变更的逻辑  [reducer]</p><p>那么，应用 redux 能够给我们带来的好处在于：</p></li><li><p>持久化状态数据</p></li><li><p>ssr</p></li><li><p>实现undo、redo操作</p></li><li><p>应用状态的时间旅行管理</p></li><li><p>多用户协同开发</p></li><li><p>开发工具扩展能力</p></li><li><p>强大的组合能力</p></li></ul><p>redux 提供的是一套全局的状态管理能力，如果你当前组件只需要本地 state 就能维护好应用状态，就没有必要引入 redux。只有当我们面临着以下场景：</p><ul><li>某个组件的状态，需要共享</li><li>某个状态需要在任何地方都可以拿到</li><li>一个组件需要改变全局状态</li><li>一个组件需要改变另一个组件的状态</li></ul><p>redux 提供的解决方案就能有效地帮助我们管理数据的复杂性。</p><h2 id="2-学习-redux-之前的预备知识">2. 学习 redux 之前的预备知识？</h2><ul><li>react 应用 state 和 props 进行应用管理</li><li>react 中应用 HOC 进行代码抽象和复用</li><li>Context 全局对象</li><li>Smart、 Dumb组件</li><li>具体见<a href="https://reactjs.org/docs/hello-world.html">官网文档</a></li></ul><h2 id="3-redux-的基础知识">3. redux 的基础知识</h2><ul><li><p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html">1. Redux 入门教程</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">2. 中间件与异步操作</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html">3. react-redux</a></p></li></ul><h2 id="4-redux-数据结构">4. redux 数据结构</h2><p>  经常遇到的一个问题是：</p><p>  <strong>什么时候使用 Redux store，什么时候使用 React state？</strong></p><p>  <img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2018-05-17-redux-best-practice/image/redux_state.png" alt="redux_state"/></p><p>  <a href="https://redux.js.org/faq/organizing-state#organizing-state-only-redux-state">redux 官方文档给出的回答</a>是：</p><ul><li><p>如果明确状态变更只会影响当前组件，类似于按钮状态，输入框状态，内部数据联动展示、弹窗展示等，都建议放到 state 里面进行管理</p></li><li><p>当以下场景回答为“是”时，redux store 就是更好的选择：</p><ul><li>应用中的其他部分需要用到这部分数据吗？</li><li>是否需要根据这部分原始数据创建衍生数据？</li><li>这部分相同的数据是否用于驱动多个组件？</li><li>你是否需要能够将数据恢复到某个特定的时间点（比如：在时间旅行调试的时候）？</li><li>是否需要缓存数据？（比如：直接使用已经存在的数据，而不是重新请求）</li></ul><p>实际上，我们需要一套更通用的方案来指导如何架构redux store。按照我们的实际开发经验来看，可以将数据分为<code>ui状态</code>和<code>数据逻辑</code>:</p></li></ul><h3 id="ui状态">ui状态</h3><p>  可以包括<code>弹窗展示</code>、<code>tab切换</code>，<code>下拉菜单</code>等不涉及数据逻辑的状态，通常这些更适合放在<code>React state</code>管理。</p><h3 id="数据逻辑">数据逻辑</h3><p> 我们可以通过<strong>数据持久度</strong>和<strong>数据消费程度</strong>来区分数据类型：</p><h4 id="数据持久度">数据持久度</h4><ul><li>快速变更型</li><li>中等持续型</li><li>长远稳定型</li></ul><p> <strong>快速变更型</strong>，这类数据往往代表着短时间内快速变更，比如文本框内容可能随着用户输入持续变化，或者快速拖动变更位置等，这类数据更加适合维护在state中。</p><p> <strong>中等持续性</strong>，当用户浏览或者使用应用时，在刷新页面之前数据保持相对稳定，比如ajax获取数据，编辑form表单等，这类数据比较通用，可能被其他组件所应用。这类数据适合通过redux store维护，再通过connect被组件使用。</p><p> <strong>长远稳定型</strong>，指在页面多次刷新或者多次访问期间都保持不变的数据，这类数据通常不会放在redux里面维护，一般会放到localstorage或者db里面。</p><h4 id="数据消费程度">数据消费程度</h4><p>  数据特性体现在消费层面，即有多少组件需要使用。越多组件消费的数据，就应该放在 redux store 里面维护，反之，当数据只服务于单一组件时，由 React State 维护就更加合理。</p><p>  <strong>最后，什么情况该使用哪种数据管理方式，是 React 维护 state 还是 Redux 集中管理，这个讨论不会有唯一定论。这需要开发者对于 React，Redux 深入理解，并结合场景需求完成选择。</strong></p><h2 id="5-fsa-设计规范">5. FSA 设计规范</h2><p>redux 设计非常精简，并没有追求大而全。在具体实践上，官方并没有约定一套通用的标准，在开发社区里面有很多的约定方案，其中最广为接受的方案就是<a href="https://github.com/redux-utilities/flux-standard-action">FSA</a>，全称是 <code>flux-standard-action</code>。</p><p><code>FSA</code> 的设计理念在于规范 <code>action</code> 的标准写法，让开发者都遵循同一套规范，简单友好可依赖。具体的标准如下：</p><ul><li><code>action</code> 是一个纯对象</li><li>必须要有 <code>type</code> 字段，来表示 action 类型</li><li>至少要有 <code>error</code>，<code>payload</code>, <code>meta</code> 属性之一</li><li>若 <code>action</code> 报错，<code>error</code> 必须为 true</li><li>不能有<code>type</code>, <code>error</code>，<code>payload</code>, <code>meta</code> 之外的其他属性 </li></ul><h3 id="type">type</h3><p>[必选] <code>type</code> 属性必须是字符串类型常量，通过 <code>type</code> 可以将 <code>action</code> 和 <code>reducer</code> 串联起来。</p><h3 id="payload">payload</h3><p>[可选] payload 代表 action 存放的内容，可以是任意类型的数据。当<code>error</code>值为 true 时，此时 payload 应当是一个 Error 对象</p><h3 id="error">error</h3><p>[可选] error 当取值为 true 时，此时 action 发生了错误</p><h3 id="meta">meta</h3><p>[可选] action 的额外信息，典型使用场景就是当 action payload 是一个 promise 时，通过 meta 来传递相应参数。</p><p>正式基于相同的 action 架构，<code>redux-actions</code>，<code>redux-promise-middle</code> 都是基于 <code>FSA</code> 架构的 action 处理工具。</p><h2 id="6-redux-store-设计">6. redux store 设计</h2><p>redux Store 是整个应用的核心，决定了应用如何渲染，渲染的结果是什么。所以设计好 redux store 是重中之重。</p><p>在设计 redux store 之前，我们先聊一下应用的架构。说到底，store 设计是需要服务应用架构的，离开项目需求单独讨论 store 是无本之木。</p><p>目前信贷中后台页面都是基于 papaya 的单页架构，单页架构又分为两种：</p><ul><li>A：每个页面都是一个独立的模块，页面切换会刷新当前页面，页面之间不需要共享全局状态（流程引擎）</li><li>B：纯粹单页应用，多个模块共同组成一个页面，模块切换不会刷新当前页面，需要共享全局状态（机器学习）</li></ul><p>这两类应用所维护的 store 架构就需要分开设计。</p><p><strong>从横向来看</strong>，「A应用」就适合于按「Page 页面」进行分类，也不需要抽取共享状态用于页面间分享：</p><pre><code>- page1
  - module1
  - module2
  - module3
- page2
</code></pre><p>「B应用」更适合于按照「Feature 功能」进行分类，模块之间需要抽象出全局共享状态：</p><pre><code>- app（全局共享状态）
- routing（路由数据）
- module1
- module2
</code></pre><p><strong>从纵向来看</strong>，store 设计通用设计可以参考：</p><ul><li>store 设计尽量扁平化，store 里面 state 结构不要超过 3 层，数据之间可以通过 <code>id</code> 进行连接</li><li>多个模块之间需要共享的数据，放到父模块存储</li></ul><h2 id="7-reducer-设计">7. reducer 设计</h2><p>redux 官方示范给的 reducer 写法：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">function</span> <span class="token function">todos</span><span class="token punctuation">(</span><span class="token parameter">state <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">case</span> <span class="token constant">ADD_TODO</span><span class="token operator">:</span>
      <span class="token comment">// return state1</span>
    <span class="token keyword">case</span> <span class="token constant">TOGGLE_TODO</span><span class="token operator">:</span>
      <span class="token comment">// return state2</span>
    <span class="token keyword">default</span><span class="token operator">:</span>
      <span class="token keyword">return</span> state
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>这种写法很好，但是不够精简，我们完全可以代替以 对象 写法：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">import</span> typeToReducer <span class="token keyword">from</span> <span class="token string">'type-to-reducer'</span>

<span class="token keyword">const</span> todosReducer <span class="token operator">=</span> <span class="token function">typeToReducer</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">ADD_TODO</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>state1<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token constant">TOGGLE_TODO</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>state2<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><p>不仅代码更加精简，语义性也变得更强了，并且还减少了维护成本，一举三得。</p><h2 id="8-redux-actions">8. redux actions</h2><p>基于 <code>FSA</code> 架构，我们可以产出两套<code>action</code> 方案：</p><h3 id="actioncreator-写法">actionCreator 写法</h3><p><code>actionCreator</code> 写法接近于原生 action 写法:</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token comment">// 一个标准的actionCreator 同步写法</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">setWorkSpaceRectData</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> types<span class="token punctuation">.</span><span class="token constant">SET_WORKSPACE_RECT_DATA</span><span class="token punctuation">,</span>
    <span class="token literal-property property">payload</span><span class="token operator">:</span> <span class="token punctuation">{</span>value<span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token comment">// 一个标准的actionCreator 异步写法</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">queryAppList</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">userName</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> types<span class="token punctuation">.</span><span class="token constant">QUERY_APP_LIST</span><span class="token punctuation">,</span>
    <span class="token literal-property property">payload</span><span class="token operator">:</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/serving/users/apps</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token literal-property property">meta</span><span class="token operator">:</span> userName
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="redux-action-写法">redux-action 写法</h3><p>社区提供另外一个简化action写法的解决方案，<a href="https://github.com/redux-utilities/redux-actions">redux-actions</a>，基于 redux-actions 对上述 action 做下改造：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">import</span> <span class="token punctuation">{</span> createAction <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux-actions'</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> setWorkSpaceRectData <span class="token operator">=</span> <span class="token function">createAction</span><span class="token punctuation">(</span>
  types<span class="token punctuation">.</span><span class="token constant">SET_WORKSPACE_RECT_DATA</span><span class="token punctuation">,</span>
  <span class="token parameter">value</span> <span class="token operator">=></span> <span class="token punctuation">{</span>value<span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> queryAppList <span class="token operator">=</span> <span class="token function">createAction</span><span class="token punctuation">(</span>
  types<span class="token punctuation">.</span><span class="token constant">QUERY_APP_LIST</span><span class="token punctuation">,</span>
  <span class="token parameter">userName</span> <span class="token operator">=></span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/serving/users/apps</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token parameter">userName</span> <span class="token operator">=></span> userName
<span class="token punctuation">)</span>
</code></pre><p>个人还是偏向原生写法，redux-action 将 action 属性封装以后反而加大了理解难度。</p><h2 id="9-redux-中间件">9. redux 中间件</h2><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016092002.jpg" alt="redux-middleware"/></p><p>redux 的中间件模型类似于 koa 的洋葱模型，对<code>store.dispatch</code>方法进行改造，就可以添加功能，具体原理参考<a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">2. 中间件与异步操作</a>。这里只是推荐一些常用的中间件。</p><h3 id="91-redux-thunk">9.1 redux-thunk</h3><p>redux 原生设计只支持同步 Action，redux-thunk 的原理是 action 进行拦截判断，如果 thunk 发现 action 类型是函数，就在action 回调里面再触发 action，这也是 redux 异步方案的通用解决方案。</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">const</span> <span class="token function-variable function">getDataAction</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 1. 这里 生成的action 是一个函数，通过thunk 包装以后，实际触发的action 是 action 2</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">dispatch<span class="token punctuation">,</span> getState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 2. 这里才是真正触发的action</span>
    <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token constant">GET_DATA</span><span class="token punctuation">,</span> 
      <span class="token literal-property property">payload</span><span class="token operator">:</span> id
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token function">getDataAction</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><h3 id="92-redux-promise-middleware">9.2 redux-promise-middleware</h3><p>redux-thunk 能够实现异步action，但是无法实现异步 action 的串联</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token function">action1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">action2</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>并且<code>redux-thunk</code>写法非常冗余，需要针对异步action 手工添加状态信息，<code>redux-promise-middleware</code> 则会自动生成
<code>actionType_${status}</code>的 type 类型，结合<a href="https://github.com/tomatau/type-to-reducer">type-to-reducer</a>就能实现很好地代码优化。</p><h3 id="93-redux-logger">9.3 redux-logger</h3><p>redux-logger 能够将 action 打印到控制台，非常方便 debug。</p><h3 id="94-redux-devtools-extension">9.4 redux-devtools-extension</h3><p>redux 作者维护的结合浏览器插件的开发神器。</p><h2 id="qa">QA</h2><p>1 是否允许按需 connect？</p><blockquote><p>允许。具体还是从业务层面需求出发，如果当前组件我们认为其更加适合作为一个容器型组件，也就是跟业务数据有很强的关联，这个时候connect 就是比较好的选择，反之，如果当前组件更偏向于展示型，那么数据来源更合适从父组件获取，而非 connect。</p><p>关于何时 connect 比较合适，目前无法提供一套通用的解决方案，还是需要从实际业务中去判断，一个原则是 当需要跟业务数据强关联，就合适 connect，反之如果组件更适合作为展示组件，就更适合从父组件上获取数据。</p></blockquote><p>2 目录结构划分，是按照action，reducer，constant 按功能进行页面区分，还是支持像 <a href="https://github.com/erikras/ducks-modular-redux">ducks</a> 将所有文件统一管理？</p><blockquote><p><a href="https://github.com/erikras/ducks-modular-redux">ducks</a>写法推崇将 actionCreator，reducer，constant 都写到同一个文件里，优点在于减少页面切换。但 redux 作者并不赞同，因为这种写法会给用户造成 action 和 reducer 是一一对应的错误，并且当 action 需要共享 reducer 时，无法做到抽象。</p><p><strong>结论</strong>，优先推荐使用 ducks 写法，如果有复杂数据处理场景，建议采用按功能区分的写法。</p></blockquote><p>3 immutable 在哪里 toJS？</p><blockquote><p>immutable 在 connect 里面 toJS 是一种反模式，并且在展示组件（Dumb）里面是否应用 immutable 对象，<a href="https://redux.js.org/recipes/using-immutable.js-with-redux#never-use-immutable-js-in-your-dumb-components">官方并不推荐</a>，实际上如果组件之间传递的是 immutable 对象对性能提升有一定的帮助。</p><p><strong>结论</strong>，toJS 建议按需来转，比如当跟服务端进行数据交互时就应该执行 toJS 操作。另外，展示组件 推荐传递非 immutalble 对象，当需要性能优化时，可以考虑传递 immutable 对象</p></blockquote><p>4 一个 action 是否需要聚合所有操作？</p><blockquote><p>action 聚合最合适的时候应该交由 view 层控制，每个 action 维护的都是最小单元的数据操作逻辑。通过<code>redux-promise-middleware</code> 可以实现 异步action 串联和聚合效果。</p><p>另外，即使这种情况下，因为无法保证所有 action 都能返回 promise，所以<strong>不建议移除 redux-thunk</strong>。</p></blockquote><p>5 目前在papaya 中使用的 FSA、 type-to-reducer、ducks 这种是否为强制规范？</p><blockquote><p>FSA 是目前 redux 社区推荐的方案，建议使用，type-to-reducer 能够帮助书写更优雅的reducer，并且是对 redux-promise-middleware 的优化写法，ducks 可以减少文件维护成本。</p><p><strong>结论</strong>，推荐使用FSA、type-to-reducer、ducks 等写法。</p></blockquote><p>6 哪种情况数据应该放在 state 中，哪种应该放在 store 中？</p><blockquote><p>参考 [redux数据结构](#4. redux 数据结构)</p></blockquote><p>7 什么情况下使用 action , 什么情况下使用静态方法？</p><blockquote><p>如果涉及到后端请求或前端查询数据，即使不用关心action操作返回的值，也建议使用action，因为后续如果需求改动或者数据变更，有更好的可扩展性。静态方法适合于跟数据逻辑无关的 ui 状态。</p></blockquote><p>8 如何组织一个前端业务操作流，例如：执行了发货操作，操作成功，执行查询操作，再执行 xxx 操作。。。</p><blockquote><p>在 React 层来调用相应 action：</p></blockquote><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">mail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res2</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
        <span class="token comment">// something else</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>9 promiseMiddleware 的最佳实践和反模式？</p><blockquote><p><a href="https://github.com/pburtchaell/redux-promise-middleware/tree/master/docs/guides">官方文档</a></p></blockquote></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[React 你不知道的那些事儿]]></title>
            <link>/blog/posts/2018-08-15/you-dont-know-react/</link>
            <guid>/blog/posts/2018-08-15/you-dont-know-react/</guid>
            <content:encoded><![CDATA[<div><blockquote><p>注：本文写于 2018 年，基于 react 15 的一些实践分享，部分内容已经不太符合目前 react 16 的架构，请谨慎采纳</p></blockquote><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2018-08-15-you-dont-know-react/image/graphic.png" alt="react-graphic"/></p><p>React 上手很简单，初次接触 React 的同学花半天时间差不多就能看完 React 官网文档。但要真正掌握 React 是一个漫长的过程，React 真正的威力在于其背后庞大繁荣的生态圈，redux、react-router、mobX、create-react-app、GraphQL 等，你要学习的不是一个库，也不是一个框架，而是一整套技术栈，和完整的 React 的思维方式。 </p><p>本文不介绍 React 基础知识，也不介绍 React 库 的具体用法，我会分享一些 React 实战开发中的 ”令人眼前一亮“ 的案例，希望能够对你有一定的启发。当然如果你有更好的 case 分享，欢迎评论。</p><h3 id="1-component">1. Component</h3><p>React 有三种组件构建方式：</p><ul><li>React.Component</li><li>React.pureComponent</li><li>stateless Component</li></ul><p>这三种组件区别可以参考 <a href="https://reactjs.org/docs/components-and-props.html">官方文档</a>，这里要聊得是如何选择组件类型：</p><p>通常我们可以按照以下逻辑来确定组件应用场景：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">if</span> <span class="token punctuation">(</span>componentHasNoState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// 1. 如果组件不需要维护应用状态，选择 stateless Component</span>
 <span class="token keyword">return</span> <span class="token function">itsStatelessComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>componentHasSimplePropsState <span class="token operator">&amp;&amp;</span> propsHasNoNestedObjects<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// 2. 如果组件属性简单，并且不含有嵌套数据，选择 pureComponent</span>
 <span class="token keyword">return</span> <span class="token function">itsPureComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
 <span class="token comment">// 3. 其他情况选择 Component</span>
 <span class="token keyword">return</span> <span class="token function">itsComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><blockquote><p>补充：</p><p>React.pureComponent 对于高响应组件（Input 等）也不建议使用，每次比较props有性能消耗。</p></blockquote><h3 id="2-refs">2. refs</h3><p>React 通过声明式的渲染机制把复杂 DOM 操作简化为 state 和 props 操作，但某些特场景，我们仍然离不开 DOM 操作和跨组件调用，React 开放了 ref 属性可以方便我们操作 DOM 和 调用其他组件实例。</p><p>React <a href="https://reactjs.org/docs/refs-and-the-dom.html">创建 ref 有三种方式</a>：</p><ul><li>string 类型 ref - <strong>deprecated，不推荐使用</strong></li><li>callback ref - 推荐使用</li><li>React.createRef() - <strong>React 16 后添加，推荐使用</strong></li></ul><p>ref 使用有几点需要特别注意：</p><ul><li>stateless 组件上无法直接使用，因为stateless 组件无实例</li></ul><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">function</span> <span class="token function">MyFunctionalComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>input <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>textInput <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 错误，无状态组件没有实例</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>MyFunctionalComponent ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>textInput<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><ul><li>stateless 组件内部可以使用 ref</li></ul><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">function</span> <span class="token function">CustomTextInput</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ref 需要在组件初始化就创建</span>
  <span class="token keyword">let</span> textInput <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 无状态组件内部可以创建ref</span>
    textInput<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">></span>
      <span class="token operator">&lt;</span>input
        type<span class="token operator">=</span><span class="token string">"text"</span>
        ref<span class="token operator">=</span><span class="token punctuation">{</span>textInput<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>

      <span class="token operator">&lt;</span>input
        type<span class="token operator">=</span><span class="token string">"button"</span>
        value<span class="token operator">=</span><span class="token string">"Focus the text input"</span>
        onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span>
      <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><ul><li>innerRef 跨组件调用</li></ul><p>当我们需要在父组件上拿到子组件的 DOM 元素时，我们可以传递一个自定义 innerRef 直接从父组件上拿到子组件的 DOM 元素：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">function</span> <span class="token function">CustomTextInput</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">></span>
      <span class="token operator">&lt;</span>input ref<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>innerRef<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">_setRef</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>inputElement <span class="token operator">=</span> el
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>CustomTextInput
        innerRef<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>_setRef<span class="token punctuation">}</span>
      <span class="token operator">/</span><span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><ul><li>ref 在 HOC 中传递</li></ul><p>ref 属性类似于 key, 本质是给 React 内部使用的，无法通过 props 进行传递。在 HOC 高阶组件内部，ref 往往不能正确获得内部实例，类似于 <a href="https://github.com/reduxjs/react-redux/blob/d769be59dafde13cee509185f1bab385b90dd9e7/src/components/connectAdvanced.js#L179-L189">react-redux 实现</a>，我们需要对组件增加 getWrappedInstance 和 setWrappedInstance 方法：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">function</span> <span class="token constant">HOC</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">HOCComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>    
    <span class="token comment">// 提供对外实例的方法</span>
    <span class="token function-variable function">getWrappedInstance</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>wrappedInstance<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 实现 ref 的访问</span>
    <span class="token function-variable function">setWrappedInstance</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">ref</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>wrappedInstance <span class="token operator">=</span> ref<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>setWrappedInstance<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> HOCComponent<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> App <span class="token operator">=</span> <span class="token constant">HOC</span><span class="token punctuation">(</span>Wrap<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">&lt;</span>App ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">comp</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// 只能获取到 HOCComponent</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 通过中转后可以获取到 WrappedComponent</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comp<span class="token punctuation">.</span><span class="token function">getWrappedInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
</code></pre><ul><li>穿云箭 React.forwardRef</li></ul><p>React 16 可以通过 React.forwardRef 更加方便地从父组件传递 ref 到子组件，<code>ForwardRef</code> 字面意思就是 <code>forward(传递)ref</code>。</p><p>我们对上面定义的 HOC 高阶组件做一个改造：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">function</span> <span class="token constant">HOC</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">HOCComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>   
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span>forwardRef<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props
      <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent ref<span class="token operator">=</span><span class="token punctuation">{</span>forwardRef<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span>rest<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> React<span class="token punctuation">.</span><span class="token function">forwardRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> ref</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>HOCComponent forwardRef<span class="token operator">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> App <span class="token operator">=</span> <span class="token constant">HOC</span><span class="token punctuation">(</span>Wrap<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token operator">&lt;</span>App ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">comp</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// 此时就能直接拿到内部组件实例了</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>comp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
</code></pre><h3 id="3-react-router-支持路由动态布局">3. React-Router 支持路由动态布局</h3><p>一个复杂的单页应用往往有不止一种 页面布局 展示，比如 A 页面布局是：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token operator">&lt;</span>Header<span class="token operator">></span>
  <span class="token operator">&lt;</span>Asider<span class="token operator">></span>
  <span class="token operator">&lt;</span>Main<span class="token operator">></span>
<span class="token operator">&lt;</span>Footer<span class="token operator">></span>
</code></pre><p>B 页面的布局是：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token operator">&lt;</span>Header<span class="token operator">></span>
  <span class="token operator">&lt;</span>Main<span class="token operator">></span>
<span class="token operator">&lt;</span>Footer<span class="token operator">></span>
</code></pre><p>我们希望实现根据页面路由自定义页面布局展现。</p><p>在单一页面布局下，我们通常是这么架构应用路由：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token operator">&lt;</span>Layout<span class="token operator">></span>
  <span class="token operator">&lt;</span>Switch<span class="token operator">></span>
    <span class="token operator">&lt;</span>Route<span class="token operator">></span>
</code></pre><p>为了支持动态 <code>layout</code> 布局能力，就无法再沿用 <code>Layout</code> 嵌套 <code>Route</code> 来实现，我们希望能够实现 <code>Route</code> 嵌套 <code>Layout</code>：</p><p>类似于：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token operator">&lt;</span>Route <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span><span class="token operator">></span>
  <span class="token operator">&lt;</span>Layout <span class="token operator">/</span><span class="token operator">></span>
</code></pre><p>这样就可以实现动态路由布局能力了。</p><p><code>react-router</code> 提供了 <a href="https://reacttraining.com/react-router/web/api/Route/render-func">render</a> 方法来自定义<code>Route</code>组件。</p><p>对 Route 稍加改写就可以支持了：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">const</span> <span class="token function-variable function">BaseRoute</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span><span class="token literal-property property">component</span><span class="token operator">:</span> Component<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>Route <span class="token punctuation">{</span><span class="token operator">...</span>rest<span class="token punctuation">}</span> render<span class="token operator">=</span><span class="token punctuation">{</span><span class="token parameter">matchProps</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>BaseLayout<span class="token operator">></span>
        <span class="token operator">&lt;</span>Component <span class="token punctuation">{</span><span class="token operator">...</span>matchProps<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>BaseLayout<span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>于是我们在外部调用即可：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token operator">&lt;</span>Router<span class="token operator">></span>
  <span class="token operator">&lt;</span>Switch<span class="token operator">></span>
      <span class="token operator">&lt;</span>BaseRoute path<span class="token operator">=</span><span class="token string">'/guide'</span> exact component<span class="token operator">=</span><span class="token punctuation">{</span>QuickStart<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&lt;</span>WithoutSideBarRoute path<span class="token operator">=</span><span class="token string">'/demo'</span> exact component<span class="token operator">=</span><span class="token punctuation">{</span>Demo<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&lt;</span>Redirect to<span class="token operator">=</span><span class="token string">'/guide'</span> <span class="token operator">/</span><span class="token operator">></span>
   <span class="token operator">&lt;</span><span class="token operator">/</span>Switch<span class="token operator">></span>
<span class="token operator">&lt;</span>Router<span class="token operator">></span>
</code></pre><p>这样我们就可以将<code>Router</code>和<code>Layout</code>组合起来，衍生出各种布局能力了。</p><h3 id="4-单页应用-pv-统计">4. 单页应用 PV 统计</h3><p>传统页面 PV 统计是基于页面之间链接跳转实现，但在单页应用里页内路由替代了请求新的页面，PV 统计只在应用初始化才会触发，这就意味着我们需要新的单页应用 PV 统计方案。</p><p>我们有两种方式来实现 PV 统计：</p><ol><li>监听 hashChange 变化上报 PV</li><li>基于 decorate 装饰 Route 组件，每次参数变更上报 PV</li></ol><p>第 1 种方案很好实现，在路由文件上侦听 hashChange 事件即可</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token function-variable function">hashChangeHandle</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  ReactGA<span class="token punctuation">.</span><span class="token function">pageview</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>location<span class="token punctuation">.</span>pathname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>location<span class="token punctuation">.</span>search<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">componentDidMount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'hashchange'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hashChangeHandler<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">componentWillUnmount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'hashchange'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>hashChangeHandler<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>第二种方案的本质是当路由组件参数变更时，意味着此时路由 <code>path</code> 参数变更，直接监听 <code>componentWillReiveProps</code> 就能实现 PV 上报。我们需要一个装饰器方法将路由组件包装好。</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">const</span> <span class="token function-variable function">withRouter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>PureComponent <span class="token punctuation">{</span>
    <span class="token function-variable function">trackData</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span>location<span class="token punctuation">}</span> <span class="token operator">=</span> props
      <span class="token comment">// 上报PV</span>
      ReactGA<span class="token punctuation">.</span><span class="token function">pageview</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>location<span class="token punctuation">.</span>pathname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>location<span class="token punctuation">.</span>search<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">componentDidMount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 初始化也要上报PV</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">trackData</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">componentWillReceiveProps</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 每次路由参数变更上报PV</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">trackData</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent <span class="token punctuation">{</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">></span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>在外面调用就很简单了，将 <code>BaseRoute</code> 包装一层即可。</p><pre><code>// ....BaseRoute 原有逻辑
export default withRouter()(BaseRoute)
</code></pre><h3 id="5-权限控制">5. 权限控制</h3><p>权限控制是中后台系统的核心功能之一，权限控制一般分为页面粒度和页面元素粒度。</p><p>当我们需要对页面元素粒度进行权限控制时，譬如我们需要页面上 button 按钮根据是否有权限，来控制展示或隐藏：</p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers=""><span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span>code<span class="token punctuation">,</span> resouceList<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props
  <span class="token keyword">let</span> hasAuth <span class="token operator">=</span> resouceList<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token plain-text">
      </span><span class="token punctuation">{</span>hasAuth <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span><span class="token plain-text">创建用户</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">}</span><span class="token plain-text">
    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
    
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>一个元素这么写当然没问题，但是如果有 10 个元素需要加权限控制，或者按钮的显示逻辑修改了呢，我们需要一个更加通用的解决办法。</p><p>我们可以创建一个组件容器组件专门负责管理权限：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">function</span> <span class="token function">AuthContainer</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> resourceList<span class="token punctuation">,</span> children<span class="token punctuation">,</span> code <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> hasAuth <span class="token operator">=</span> resourceList<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span>
  <span class="token keyword">return</span> hasAuth <span class="token operator">&amp;&amp;</span> children
<span class="token punctuation">}</span>
</code></pre><p>然后将上面的组件改写一下：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span>code<span class="token punctuation">,</span> resouceList<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>AuthContainer code<span class="token operator">=</span><span class="token punctuation">{</span>code<span class="token punctuation">}</span> resouceList<span class="token operator">=</span><span class="token punctuation">{</span>resouceList<span class="token punctuation">}</span><span class="token operator">></span>
      <span class="token operator">&lt;</span>button<span class="token operator">></span>创建用户<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span><span class="token punctuation">)</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>AuthContainer<span class="token operator">></span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>重构完的代码无论是从语义性，还是扩展性都有很大的提升。</p><h3 id="6-currying-react">6. currying React</h3><p>currying 柯里化是函数式语言基础的写法，通俗化来说就是把多个参数的函数变换成接受一个个单一参数的函数，并且在最后返回新函数。</p><p>也广泛应用在 React 及其周边库的写法中，像常用<code>react-redux</code> 中 <code>connect(mapStateToProps, mapDispatchToProps)(App)</code> 就是标准的柯里化写法。</p><p>以下举个栗子来阐释柯里化在 React 开发中的实践：</p><ul><li>多个过滤条件合并</li></ul><p>现在有一个case，我们分别需要针对 price、age、brand 三个维度过滤筛选产品列表</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token comment">// 通常实现</span>
<span class="token keyword">class</span> <span class="token class-name">Filters</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token comment">// 更新价格条件</span>
  <span class="token function-variable function">updatePriceFilter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">selectionsChanged</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>filterSelections<span class="token punctuation">,</span>
      <span class="token literal-property property">price</span><span class="token operator">:</span> newValue
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 更新年龄条件</span>
  <span class="token function-variable function">updateAgeFilter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">selectionsChanged</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>filterSelections<span class="token punctuation">,</span>
      <span class="token literal-property property">ages</span><span class="token operator">:</span> newValue
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 更新品牌条件</span>
  <span class="token function-variable function">updateBrandFilter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">selectionsChanged</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>filterSelections<span class="token punctuation">,</span>
      <span class="token literal-property property">brands</span><span class="token operator">:</span> newValue
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">></span>
        <span class="token operator">&lt;</span>PriceFilter 
          priceChanged<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>updatePriceFilter<span class="token punctuation">}</span> 
        <span class="token operator">/</span><span class="token operator">></span>
        <span class="token operator">&lt;</span>AgeFilter 
          agesChanged<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>updateAgeFilter<span class="token punctuation">}</span> 
        <span class="token operator">/</span><span class="token operator">></span>
        <span class="token operator">&lt;</span>BrandFilter 
          brandsChanged<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>updateBrandFilter<span class="token punctuation">}</span> 
        <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>我们发现，三个过滤方法除了过滤条件不一样，其他代码逻辑几乎一样，如果后续再增加一个过滤条件，我们几乎是需要再拷贝一遍代码，这不科学。</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token comment">// 柯里化实现</span>
<span class="token keyword">class</span> <span class="token class-name">Filters</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token comment">// 合并过滤条件</span>
  <span class="token function-variable function">updateSelections</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">selectionType</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token parameter">newValue</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">selectionsChanged</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        <span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>filterSelections<span class="token punctuation">,</span>
        <span class="token punctuation">[</span>selectionType<span class="token punctuation">]</span><span class="token operator">:</span> newValue<span class="token punctuation">,</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">></span>
        <span class="token operator">&lt;</span>PriceFilter 
          priceChanged<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateSelections</span><span class="token punctuation">(</span><span class="token string">'price'</span><span class="token punctuation">)</span><span class="token punctuation">}</span> 
        <span class="token operator">/</span><span class="token operator">></span>
        <span class="token operator">&lt;</span>AgeFilter 
          agesChanged<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateSelections</span><span class="token punctuation">(</span><span class="token string">'age'</span><span class="token punctuation">)</span><span class="token punctuation">}</span> 
        <span class="token operator">/</span><span class="token operator">></span>
        <span class="token operator">&lt;</span>BrandFilter 
          brandsChanged<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateSelections</span><span class="token punctuation">(</span><span class="token string">'brand'</span><span class="token punctuation">)</span><span class="token punctuation">}</span> 
        <span class="token operator">/</span><span class="token operator">></span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>很明显，柯里化改造后的代码大大简化了代码逻辑，也增强后续扩展性。</p><blockquote><blockquote><p>更新 </p></blockquote><p>目前这种实现方式，还是会导致每次重新创建匿名方法，应该通过如下方式，才能避免文中所说的匿名方法重复创建问题：</p><p>updateSelectionsPrice = updateSelections(’price’)</p><p>updateSelectionsAge = updateSelections(’age’)</p><p>updateSelectionsBrand = updateSelections(’brand’)</p></blockquote><h3 id="7-recompose-让生活更美好">7. recompose 让生活更美好</h3><p><a href="https://github.com/acdlite/recompose/blob/master/docs/API.md">recompose</a> 是一个优秀的 React 社区开源库，提供了一系列小而美的高阶组件和工具类方法，可以看成是 React 的 lodash。</p><ul><li>pure：可以将函数式组件实现 PureComponent 的能力，减少重复渲染</li><li>withProps: 给组件添加属性，譬如可以将当前页面的路由信息、一些需要计算的信息作为属性注入到组件</li><li>withPropsOnChange: 类似于withProps, 当时只有当传入组件发生变更才会重新计算属性注入到组件中</li><li>defaultProps：添加默认属性（常用于公共属性的提取和添加）</li><li>setPropTypes：设置属性类型（常用于公共属性设置）</li><li>compose：将多个高阶组件组合起来</li></ul><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers="">composedHoc <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>hoc1<span class="token punctuation">,</span> hoc2<span class="token punctuation">,</span> hoc3<span class="token punctuation">)</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span>
<span class="token comment">// 实际上等于</span>
<span class="token function">hoc1</span><span class="token punctuation">(</span><span class="token function">hoc2</span><span class="token punctuation">(</span><span class="token function">hoc3</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><p>希望 recompose 同样能够成为你开发的得力助手。</p></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[React 类型探究]]></title>
            <link>/blog/posts/2018-12-28/react-element/</link>
            <guid>/blog/posts/2018-12-28/react-element/</guid>
            <content:encoded><![CDATA[<div><blockquote><p>来自网友 @chongya 原创</p></blockquote><h2 id="1-reactelement">1. <code>ReactElement</code></h2><p><code>ReactElement</code> 是构建 <code>React</code> 应用的<strong>最小单元</strong>。</p><p><code>ReactElement</code> 是 <code>React</code> 用来描述真实 <code>DOM</code> 元素的制造出来的 <code>js</code> 对象，其主要属性如下表：</p><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>key</td><td>Key / null</td><td>元素唯一标识</td></tr><tr><td>type</td><td>string / ComponentType</td><td>元素类型（字符串代表 <code>DOM Element</code>，函数和类代表 <code>Component Element</code>）</td></tr><tr><td>props</td><td>object</td><td>元素属性集合</td></tr></tbody></table><p>完整的定义为：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers="">type Key <span class="token operator">=</span> string <span class="token operator">|</span> number<span class="token punctuation">;</span>
type ComponentType<span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">></span> <span class="token operator">=</span> ComponentClass<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span> <span class="token operator">|</span> StatelessComponent<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name">ReactElement</span><span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token literal-property property">key</span><span class="token operator">:</span> Key <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> string <span class="token operator">|</span> ComponentType<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token constant">P</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="11-domelement">1.1 <code>DOMElement</code></h3><p>当 <code>ReactElement.type</code> 为 <code>string</code> 时候，<code>ReactElement</code> 可看作 <code>DOMElement</code>，<code>DOMElement</code> 的定义如下：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">interface</span> <span class="token class-name">DOMElement</span><span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token keyword">extends</span> <span class="token class-name">HTMLAttributes</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token operator">|</span> SVGAttributes<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Element</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">ReactElement</span><span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> string<span class="token punctuation">;</span>
  <span class="token literal-property property">ref</span><span class="token operator">:</span> Ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p><code>DOMElement</code> 又分为两大类 <code>ReactHTMLElement</code> 和 <code>ReactSVGElement</code>:</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">interface</span> <span class="token class-name">ReactHTMLElement</span><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">HTMLElement</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">DetailedReactHTMLElement</span><span class="token operator">&lt;</span>AllHTMLAttributes<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">DetailedReactHTMLElement</span><span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token keyword">extends</span> <span class="token class-name">HTMLAttributes</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">HTMLElement</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">DOMElement</span><span class="token operator">&lt;</span><span class="token constant">P</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> keyof ReactHTML<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
  
<span class="token keyword">interface</span> <span class="token class-name">ReactSVGElement</span> <span class="token keyword">extends</span> <span class="token class-name">DOMElement</span><span class="token operator">&lt;</span>SVGAttributes<span class="token operator">&lt;</span>SVGElement<span class="token operator">></span><span class="token punctuation">,</span> SVGElement<span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> keyof ReactSVG<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="12-componentelement--sfcelement">1.2 <code>ComponentElement</code> &amp; <code>SFCElement</code></h3><p><code>ReactElement.type</code> 类型为 <code>string | ComponentType</code>，其中 <code>ComponentType</code> 的类型定义如下：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers="">type ComponentType<span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">></span> <span class="token operator">=</span> ComponentClass<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span> <span class="token operator">|</span> StatelessComponent<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span>
</code></pre><ul><li><code>ComponentClass</code>:
<code>ComponentClass</code> 即代表 <code>class</code> 类型的组件，它有自己的构造函数 <code>Component</code>， <code>ComponentClass</code> 定义如下：</li></ul><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token comment">// 基本 ComponentClass</span>
<span class="token keyword">interface</span> <span class="token class-name">ComponentClass</span><span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">new</span> <span class="token punctuation">(</span>props<span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">P</span><span class="token punctuation">,</span> context<span class="token operator">?</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token operator">:</span> Component<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token punctuation">,</span> ComponentState<span class="token operator">></span><span class="token punctuation">;</span>
  propTypes<span class="token operator">?</span><span class="token operator">:</span> ValidationMap<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span>
  contextTypes<span class="token operator">?</span><span class="token operator">:</span> ValidationMap<span class="token operator">&lt;</span>any<span class="token operator">></span><span class="token punctuation">;</span>
  childContextTypes<span class="token operator">?</span><span class="token operator">:</span> ValidationMap<span class="token operator">&lt;</span>any<span class="token operator">></span><span class="token punctuation">;</span>
  defaultProps<span class="token operator">?</span><span class="token operator">:</span> Partial<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span>
  displayName<span class="token operator">?</span><span class="token operator">:</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ClassicComponentClass 继承自 ComponentClass</span>
<span class="token keyword">interface</span> <span class="token class-name">ClassicComponentClass</span><span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">ComponentClass</span><span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token keyword">new</span> <span class="token punctuation">(</span>props<span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">P</span><span class="token punctuation">,</span> context<span class="token operator">?</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token operator">:</span> ClassicComponent<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token punctuation">,</span> ComponentState<span class="token operator">></span><span class="token punctuation">;</span>
  getDefaultProps<span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">P</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>由 <code>ComponentClass</code> 构造出来的 <code>ReactElement</code> 叫做 <code>ComponentElement</code>，定义如下：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">interface</span> <span class="token class-name">ComponentElement</span><span class="token operator">&lt;</span><span class="token constant">P</span><span class="token punctuation">,</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span><span class="token operator">&lt;</span><span class="token constant">P</span><span class="token punctuation">,</span> ComponentState<span class="token operator">>></span> <span class="token keyword">extends</span> <span class="token class-name">ReactElement</span><span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> ComponentClass<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span>
  ref<span class="token operator">?</span><span class="token operator">:</span> Ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><ul><li><code>StatelessComponent</code>:
<code>StatelessComponent</code> 即无状态组件，简称 <code>SFC</code>，定义如下：</li></ul><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers="">type <span class="token constant">SFC</span><span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">></span> <span class="token operator">=</span> StatelessComponent<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name">StatelessComponent</span><span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span>props<span class="token operator">:</span> <span class="token constant">P</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> children<span class="token operator">?</span><span class="token operator">:</span> ReactNode <span class="token punctuation">}</span><span class="token punctuation">,</span> context<span class="token operator">?</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token operator">:</span> ReactElement<span class="token operator">&lt;</span>any<span class="token operator">></span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  propTypes<span class="token operator">?</span><span class="token operator">:</span> ValidationMap<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span>
  contextTypes<span class="token operator">?</span><span class="token operator">:</span> ValidationMap<span class="token operator">&lt;</span>any<span class="token operator">></span><span class="token punctuation">;</span>
  defaultProps<span class="token operator">?</span><span class="token operator">:</span> Partial<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span>
  displayName<span class="token operator">?</span><span class="token operator">:</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>由 <code>SFC</code> 构造出来的 <code>ReactElement</code> 叫做 <code>SFCElement</code>，定义如下：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">interface</span> <span class="token class-name">SFCElement</span><span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">ReactElement</span><span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token constant">SFC</span><span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>可以看出，与 <code>DOMElement</code> 与 <code>ComponentElement</code> 相比，<code>SFCElement</code> 不含 <code>ref</code></p><h2 id="2-component">2. <code>Component</code></h2><p><code>Component</code> 继承自 <code>ComponentLifecycle</code>（组件生命周期），同时通过 <code>Component</code> 又派生出 <code>PureComponent</code> 和 <code>ClassicComponent</code>，定义如下：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">interface</span> <span class="token class-name">ComponentLifecycle</span><span class="token operator">&lt;</span><span class="token constant">P</span><span class="token punctuation">,</span> <span class="token constant">S</span><span class="token operator">></span> <span class="token punctuation">{</span>
  componentWillMount<span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  componentDidMount<span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  componentWillReceiveProps<span class="token operator">?</span><span class="token punctuation">(</span>nextProps<span class="token operator">:</span> Readonly<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token literal-property property">nextContext</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  shouldComponentUpdate<span class="token operator">?</span><span class="token punctuation">(</span>nextProps<span class="token operator">:</span> Readonly<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token literal-property property">nextState</span><span class="token operator">:</span> Readonly<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token literal-property property">nextContext</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  componentWillUpdate<span class="token operator">?</span><span class="token punctuation">(</span>nextProps<span class="token operator">:</span> Readonly<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token literal-property property">nextState</span><span class="token operator">:</span> Readonly<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token literal-property property">nextContext</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  componentDidUpdate<span class="token operator">?</span><span class="token punctuation">(</span>prevProps<span class="token operator">:</span> Readonly<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token literal-property property">prevState</span><span class="token operator">:</span> Readonly<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token literal-property property">prevContext</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  componentWillUnmount<span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Component</span><span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token constant">S</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">ComponentLifecycle</span><span class="token operator">&lt;</span><span class="token constant">P</span><span class="token punctuation">,</span> <span class="token constant">S</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
  <span class="token keyword">class</span> <span class="token class-name">Component</span><span class="token operator">&lt;</span><span class="token constant">P</span><span class="token punctuation">,</span> <span class="token constant">S</span><span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>props<span class="token operator">?</span><span class="token operator">:</span> <span class="token constant">P</span><span class="token punctuation">,</span> context<span class="token operator">?</span><span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">;</span>
    setState<span class="token operator">&lt;</span><span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token class-name">keyof</span> <span class="token constant">S</span><span class="token operator">></span><span class="token punctuation">(</span>
      <span class="token literal-property property">state</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">prevState</span><span class="token operator">:</span> Readonly<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">></span><span class="token punctuation">,</span> <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token constant">P</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>Pick<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token constant">S</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>Pick<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">></span> <span class="token operator">|</span> <span class="token constant">S</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      callback<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> any
    <span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>

    <span class="token function">forceUpdate</span><span class="token punctuation">(</span>callBack<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> any<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">JSX</span><span class="token punctuation">.</span>Element <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token literal-property property">props</span><span class="token operator">:</span> Readonly<span class="token operator">&lt;</span><span class="token punctuation">{</span> children<span class="token operator">?</span><span class="token operator">:</span> ReactNode <span class="token punctuation">}</span><span class="token operator">></span> <span class="token operator">&amp;</span> Readonly<span class="token operator">&lt;</span><span class="token constant">P</span><span class="token operator">></span><span class="token punctuation">;</span>
    <span class="token literal-property property">state</span><span class="token operator">:</span> Readonly<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">></span><span class="token punctuation">;</span>
    <span class="token literal-property property">context</span><span class="token operator">:</span> any<span class="token punctuation">;</span>
    <span class="token literal-property property">refs</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token punctuation">[</span>key<span class="token operator">:</span> string<span class="token punctuation">]</span><span class="token operator">:</span> ReactInstance
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">PureComponent</span><span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token constant">S</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Component</span><span class="token operator">&lt;</span><span class="token constant">P</span><span class="token punctuation">,</span> <span class="token constant">S</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">ClassicComponent</span><span class="token operator">&lt;</span><span class="token constant">P</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token constant">S</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Component</span><span class="token operator">&lt;</span><span class="token constant">P</span><span class="token punctuation">,</span> <span class="token constant">S</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token function">replaceState</span><span class="token punctuation">(</span>nextState<span class="token operator">:</span> <span class="token constant">S</span><span class="token punctuation">,</span> callback<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> any<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token function">isMounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  getInitialState<span class="token operator">?</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">S</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h2 id="3-reactinstance">3. <code>ReactInstance</code></h2><p><code>ReactInstance</code> 既可以是 <code>Component</code> 的实例，也可以是一个 <code>Element</code>（最基础的元素）</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers="">type ReactInstance <span class="token operator">=</span> Component<span class="token operator">&lt;</span>any<span class="token operator">></span> <span class="token operator">|</span> Element
</code></pre><h2 id="4-reactnode">4. <code>ReactNode</code></h2><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers="">type ReactText <span class="token operator">=</span> string <span class="token operator">|</span> number<span class="token punctuation">;</span>
type ReactChild <span class="token operator">=</span> ReactElement<span class="token operator">&lt;</span>any<span class="token operator">></span> <span class="token operator">|</span> ReactText<span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name">ReactNodeArray</span> <span class="token keyword">extends</span> <span class="token class-name">Array</span><span class="token operator">&lt;</span>ReactNode<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
type ReactFragment <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">|</span> ReactNodeArray<span class="token punctuation">;</span>

type ReactNode <span class="token operator">=</span> ReactChild <span class="token operator">|</span> ReactFragment <span class="token operator">|</span> boolean <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
</code></pre><h2 id="5-syntheticevent">5. <code>SyntheticEvent</code></h2><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">interface</span> <span class="token class-name">SyntheticEvent</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">></span> <span class="token punctuation">{</span>
  <span class="token literal-property property">bubbles</span><span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  <span class="token literal-property property">currentTarget</span><span class="token operator">:</span> EventTarget <span class="token operator">&amp;</span> <span class="token constant">T</span><span class="token punctuation">;</span>
  <span class="token literal-property property">cancelable</span><span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  <span class="token literal-property property">defaultPrevented</span><span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  <span class="token literal-property property">eventPhase</span><span class="token operator">:</span> number<span class="token punctuation">;</span>
  <span class="token literal-property property">isTrusted</span><span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  <span class="token literal-property property">nativeEvent</span><span class="token operator">:</span> Event<span class="token punctuation">;</span>
  <span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token function">isDefaultPrevented</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  <span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token function">isPropagationStopped</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  <span class="token function">persist</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
  <span class="token literal-property property">target</span><span class="token operator">:</span> EventTarget<span class="token punctuation">;</span>
  <span class="token literal-property property">timeStamp</span><span class="token operator">:</span> number<span class="token punctuation">;</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> string<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p>参考资料：</p><blockquote><p><a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/v15/index.d.ts">https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/v15/index.d.ts</a></p><p><a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/global.d.ts">https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/global.d.ts</a></p><p><a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts">https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts</a></p></blockquote></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[webkit 浏览器架构]]></title>
            <link>/blog/posts/2019-04-26/webkit-structure/</link>
            <guid>/blog/posts/2019-04-26/webkit-structure/</guid>
            <content:encoded><![CDATA[<div><blockquote><p>来自网友 @cukunbu 原创</p></blockquote><h2 id="process-and-thread">Process and Thread.</h2><ul><li>thread 是 process 的一部分</li></ul><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/process-thread.png" alt="process and threads"/></p><ul><li>可以开启多个 process，process 之间通过  <strong>IPC（Inter Process Communication）</strong>  交互。</li></ul><h2 id="浏览器架构">浏览器架构</h2><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/browserui.png" alt="Chrome processes"/></p><table><thead><tr><th>process 类型</th><th>内容</th></tr></thead><tbody><tr><td>Browser</td><td>1. chrome 应用。包含 address bar, bookmarks, back and forward buttons. 2. 还处理Web浏览器的不可见特权部分，例如网络请求和文件访问。</td></tr><tr><td>Renderer</td><td>tab 内容展示</td></tr><tr><td>Plugin</td><td>浏览器插件，比如 flash</td></tr><tr><td>GPU</td><td>处理其他 process 的 GPU 任务</td></tr></tbody></table><ul><li>每个 Tab/iframe 会运行一个独立的 render process。<ul><li>独立 render process 可以当某个 Tab 崩溃，其他 Tab 正常工作</li><li>独立 render process 保证了每个 iframe 访问的数据必须满足 same origin(同源政策) 。</li></ul></li></ul><h2 id="页面跳转">页面跳转</h2><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/browserprocesses.png" alt="thread"/></p><p>从 browser process 开始，包含 UI thread / Network thread / storage thread</p><h3 id="步骤">步骤：</h3><ul><li><p>输入网址</p></li><li><p>回车确认</p><ul><li>UI thread 初始化请求， network thread 查询 DNS / 建立 TLS 连接。此时 UI thread 使 tab 转圈圈。</li><li>这个过程中 network thread 与 UI thread 会相互通信，比如301，network 会让 UI thread 重新请求</li></ul></li><li><p>接收请求</p><ul><li><p>MIME-TYPE 校验</p></li><li><p>跨域校验</p></li><li><p>根据 MIME-TYPE 渲染数据</p></li></ul></li></ul><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/response.png" alt="HTTP response"/></p><ul><li><p>如果请求是 HTML ，则渲染页面</p><ul><li>UI thread 寻找对应的 renderer process 渲染</li></ul></li><li><p>renderer process 执行渲染</p></li><li><p>渲染完成</p><ul><li>render process 通知 browser process </li></ul></li><li><p>如果有新的 url 输入，页面需要跳转</p><ul><li>browser process 通知 render process 处理 unloaded 事件</li></ul></li></ul><h3 id="service-worker">service worker</h3><blockquote><p>service worker 会对 network 做代理，允许用户选择读取 cache 还是发送请求获取新数据。</p></blockquote><p><strong>service worker</strong> 是 js 脚本，在 render process 中运行。但是 network thread 存在在 browser process 中，browser process 要如何知晓 render process 中存在 service worker 呢？</p><p>注册 service worker 时，会在 Network thread 中留下引用值。<a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle">相关链接</a></p><h2 id="renderer-process-处理页面渲染">renderer process 处理页面渲染</h2><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/renderer.png" alt="Renderer process"/></p><ul><li>Main thread 会处理大部分内容，包括 parsing / style 计算 / layout 构建 / paint 操作/ js 执行</li><li>composition 则在单独的 compositor 执行</li></ul><h3 id="parsing">parsing</h3><ul><li>解析 DOM。对错误处理友好。</li><li>可以边解析 DOM，边请求 <code>&lt;img/&gt;</code> 等资源</li><li>js 会 block parsing</li></ul><blockquote><p><code>&lt;script&gt;</code> 标签添加 async / defer。这样不会阻断主流程
<code>&lt;link rel=&quot;preload&quot;&gt;</code> 添加 preload 标志，告诉浏览器你希望这个资源能尽快下载.</p></blockquote><h3 id="style-计算">style 计算</h3><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/computedstyle.png" alt="computed style"/></p><h3 id="layout">Layout</h3><p>浏览器会构建一个与 DOM 树类似的树，展示 x, y, width, height 信息。伪类元素也会在这个阶段应用。</p><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/layout.png" alt="layout"/></p><h3 id="paint">paint</h3><p>在这个阶段还需计算组件的 order。Layout 树会被遍历产生一个 Paint Record.</p><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/paint.png" alt="paint records"/></p><ul><li>以 pipeline 的方式进行更新</li></ul><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/pipeline.png" alt="image-20190422224904804"/></p><ul><li>js 也在 main thread 中进行，会阻碍渲染</li></ul><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/pagejank2.png" alt="jage jank by JavaScript"/></p><p>可以将 js 操作颗粒化，可以使用 requestAnimationFrame() / web worker</p><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/raf.png" alt="request animation frame"/></p><h3 id="compositing-合成">compositing 合成</h3><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-04-26-webkit-structure/image/compositing.gif" alt="Apr-25-2019_23-01-04"/></p><p>compositing 则是将 page 分成不同的 layer, 对每个 layer 都进行 raster(光栅化)，然后在  <em>compositor thread</em> 上合成(composition).
页面滚动时因为 layer 都已经 raster 完成，只需要合成。</p><p>composition 会根据 Layout tree, 构建一棵 layer tree。不是一个Element 一个layer, 具体如下 <a href="https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count">Stick to Compositor-Only Properties and Manage Layer Count</a></p><blockquote><p>compositing 不在 main thread 上完成，不需要等待  style 计算、js 执行.</p></blockquote><h3 id="css-对各个阶段的影响">CSS 对各个阶段的影响</h3><p>详情见： <a href="https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/</a></p><ul><li>transform 与 opacity 会在compositor thread 中处理，不会影响主线程。</li><li>回流(reflows) 影响了 layout，重绘(repaint) 影响了 paint 过程</li></ul><p>如何减少回流与重绘：
<a href="https://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/">ZXX 回流与重绘</a></p><h2 id="参考文献">参考文献</h2><ul><li><a href="https://developers.google.com/web/updates/2018/09/inside-browser-part1">本文英文原文</a> </li><li><a href="https://blog.logrocket.com/eliminate-content-repaints-with-the-new-layers-panel-in-chrome-e2c306d4d752">eliminate-content-repaints-with-the-new-layers-panel</a></li><li><a href="https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">high-performance-animations</a></li><li><a href="https://www.html5rocks.com/zh/tutorials/speed/layers/">Accelerated Rendering in Chrome</a></li></ul></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[大型项目 typescript + redux 实践]]></title>
            <link>/blog/posts/2019-08-01/typescript-redux/</link>
            <guid>/blog/posts/2019-08-01/typescript-redux/</guid>
            <content:encoded><![CDATA[<div><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-08-01-typescript-redux/image/ts.png" alt="image"/></p><p><strong>TLDR: 文章比较长，可以跳过直接<a href="https://wulucxy.github.io/redux-typescript-guide/">查看 Demo</a></strong></p><h3 id="前言">前言</h3><p>typescript 是一个有着类型定义的 js 语言的超集。typescript 支持最新的 ESMAScript 特性，并且支持泛型、类型定义等静态语言特征，<strong>是为了大规模应用而生</strong>。我们团队之前在内部一些项目中初步尝试了 <code>React + Redux + TypeScript</code> 组合。本文则尝试梳理基于 <code>typescript</code> 如何更合理的架构 <code>redux</code>。</p><h2 id="一-环境配置">一. 环境配置</h2><p>当前 <code>ts + react</code> 项目基础配置如下：</p><ul><li>编译：@babel/preset-typescript</li><li>开发、打包：parcel</li><li>语法校验：eslint、tsc</li></ul><p>其中引入 <code>babel/preset</code> 来替代 <code>ts-loader</code>，这样既解决了 ts 工程化构建效率问题，同时不影响类型校验，还统一了编译工具。</p><p>接入 <code>babel</code> 以后，需要对 <code>tsconfig</code> 规则稍作修改，此时 ts 的定位仅仅是类型校验，代码编译的工作就完全交给 <code>babel</code> 来处理了。</p><p><em>tsconfig.json</em></p><pre><code class="language-json" data-language="json" data-highlighted-line-numbers=""><span class="token punctuation">{</span>
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 解析为最新版本的es版本，babel 负责后续的编译</span>
    <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"esnext"</span><span class="token punctuation">,</span>
    <span class="token property">"module"</span><span class="token operator">:</span> <span class="token string">"esnext"</span><span class="token punctuation">,</span>
    <span class="token comment">// ts 的解析规则</span>
    <span class="token property">"lib"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"esnext"</span><span class="token punctuation">,</span> <span class="token string">"dom"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment">// 绝对地址按照 node_modules 解析</span>
    <span class="token property">"moduleResolution"</span><span class="token operator">:</span> <span class="token string">"node"</span><span class="token punctuation">,</span>
    <span class="token comment">// 开启 jsx</span>
    <span class="token property">"jsx"</span><span class="token operator">:</span> <span class="token string">"react"</span><span class="token punctuation">,</span>
    <span class="token comment">// 不执行构建，交由 babel 执行</span>
    <span class="token property">"noEmit"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 严格模式，包括 strictNullChecks &amp; noImplicitAny.</span>
    <span class="token property">"strict"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 跳过三方包检查</span>
    <span class="token property">"skipLibCheck"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// any 类型不警告</span>
    <span class="token property">"noImplicitAny"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// 关闭 null 严格检查</span>
    <span class="token property">"strictNullChecks"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token comment">// 将每个文件作为单独的模块</span>
    <span class="token property">"isolatedModules"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token comment">// Import non-ES modules as default imports.</span>
    <span class="token property">"esModuleInterop"</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"include"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"src"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>接下来还需要配置 <code>eslint</code> 规则：</p><p><em>.eslintrc</em></p><pre><code class="language-json" data-language="json" data-highlighted-line-numbers=""><span class="token punctuation">{</span>
  <span class="token property">"parser"</span><span class="token operator">:</span> <span class="token string">"@typescript-eslint/parser"</span><span class="token punctuation">,</span>
  <span class="token property">"parserOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"project"</span><span class="token operator">:</span> <span class="token string">"./tsconfig.json"</span><span class="token punctuation">,</span>
    <span class="token property">"ecmaVersion"</span><span class="token operator">:</span> <span class="token number">2018</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"extends"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">"@npm/standard/react"</span><span class="token punctuation">,</span>
    <span class="token string">"plugin:@typescript-eslint/recommended"</span><span class="token punctuation">,</span>
    <span class="token string">"prettier"</span><span class="token punctuation">,</span>
    <span class="token string">"prettier/@typescript-eslint"</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">"plugins"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"@typescript-eslint"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">"rules"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 自定义 lint 规则</span>
    <span class="token property">"react/prop-types"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token property">"@typescript-eslint/no-explicit-any"</span><span class="token operator">:</span> <span class="token string">"warn"</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre><p>最后一步就是在 <code>package.json</code> 里面添加脚本命令了：</p><p><em>package.json</em></p><pre><code class="language-json" data-language="json" data-highlighted-line-numbers=""><span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token property">"start"</span><span class="token operator">:</span> <span class="token string">"parcel src/public/index.html --open"</span><span class="token punctuation">,</span>
  <span class="token property">"prebuild"</span><span class="token operator">:</span> <span class="token string">"npm run build:clean"</span><span class="token punctuation">,</span>
  <span class="token property">"build:clean"</span><span class="token operator">:</span> <span class="token string">"rimraf ./dist"</span><span class="token punctuation">,</span>
  <span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"parcel build src/public/index.html --no-source-maps"</span><span class="token punctuation">,</span>
  <span class="token property">"lint"</span><span class="token operator">:</span> <span class="token string">"eslint src --fix --format codeframe"</span><span class="token punctuation">,</span>
  <span class="token property">"lint-staged"</span><span class="token operator">:</span> <span class="token string">"lint-staged"</span><span class="token punctuation">,</span>
  <span class="token property">"ts-compile-check"</span><span class="token operator">:</span> <span class="token string">"tsc --pretty -p tsconfig.json"</span>
<span class="token punctuation">}</span>
</code></pre><p>以上，我们就实现了一套完整工程化能力的 <code>typescript</code> 开发环境了。</p><blockquote><p>let’s RUN~~~</p></blockquote><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-08-01-typescript-redux/image/run.png" alt="run"/></p><h2 id="二-数据和分层">二. 数据和分层</h2><h3 id="1-目录结构">1. 目录结构</h3><p>目录即分层，一个好的目录结构能够让我们在开发中更加得心应手。在开发 redux 应用中，有一种普遍的做法是根据 <code>action</code>, <code>reducer</code> 功能进行分层，一个典型的应用是这样的：</p><pre><code>.
|-- actions             // 全局 action
|-- components          // 公共组件
|   |-- Footer.tsx
|   |-- Header.tsx
|-- pages               // 页面
|   |-- home
|      |-- components  // 组件入口  
|      `-- index.tsx   // 页面入口 
|-- reducers           // 全局 reducer
|-- store              // store 入口
|-- types.d.ts         // 三方类型声明
</code></pre><p>在实际开发中，开发往往会在不同文件中来回跳跃，尤其是当项目文件膨胀以后，在不同文件中跳跃式寻找会占据很大比例的时间。基于此，社区开始流行另外一种开发方式，俗称「ducks」规则，简而言之就是将 <code>action</code>, <code>reducer</code>，<code>actionType</code> 放在一起进行管理，<a href="https://github.com/erikras/ducks-modular-redux">参考链接</a>。 其中 <code>ducks</code> 命名来自于<code>redux</code> 结尾音。</p><p><strong>ducks</strong></p><pre><code>.
|-- components           // 公共组件
|   |-- Footer.tsx
|   |-- Header.tsx
|-- pages
|   |-- home
|   |  |-- index.ts      // 页面入口
|   |  |-- components    // 组件
|   |  |-- types.ts      // 类型声明
|   |  `-- reducer.ts    // action/reducer
|-- store                 // redux store 入口
|-- types.d.ts            // 三方组件类型声明
</code></pre><h3 id="2-数据不可变性">2. 数据不可变性</h3><p>在 redux 开发中，需要遵循的一个原则是<code>数据不可变性 (immutable)</code>，每个 reducer 不能修改原始值，而只能返回一个新的 state。</p><p>在 接触 <code>typescript</code> 之前，<a href="https://immutable-js.github.io/immutable-js/">immutable.js</a> 是结合 redux 实现数据不可变的最佳辅助工具。然而，<code>immutable.js</code> 对 <code>ts</code> 的支持就一言难尽了，这两者都是很好的工具，但是放在一起，却是那么的不合适。</p><p>所以我们在实际项目中尝试了使用 <a href="https://github.com/immerjs/immer">immer</a> 来实现数据持久化，<code>immer</code> 通过 <code>proxy</code> 实现了用原生 js 语法实现了数据不可变。虽然写起来没有像 <code>immutable.js</code> 函数式写法那么爽，但至少能用。</p><blockquote><p>后续，我们仍然会探索基于 <code>immutable.js</code> 的 <code>typescript</code> 写法，不再本文范畴之内。</p></blockquote><h3 id="3-store">3. Store</h3><p>在 <code>Store</code> 中我们将 <code>reducer</code> 进行聚合，并对外导出应用级别的状态数据。</p><p><em>src/store/root-reducers.ts</em></p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token comment">// 页面 reducer 聚合</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> ReducersMapObject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"redux"</span>
<span class="token comment">// 导入每个页面独立的 reducer 和 类型声明</span>
<span class="token keyword">import</span> bitcoin <span class="token keyword">from</span> <span class="token string">"../pages/basic/reducer"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> BitcoinState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../pages/basic/types"</span><span class="token punctuation">;</span>

<span class="token comment">// 应用级数据类型接口</span>
<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">AppState</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">bitcoin</span><span class="token operator">:</span> BitcoinState<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token literal-property property">reducers</span><span class="token operator">:</span> ReducersMapObject <span class="token operator">=</span> <span class="token punctuation">{</span>
  bitcoin
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> reducers 
</code></pre><p><em>src/store/create.ts</em></p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token comment">// 导入 redux 和 immer 相应的方法</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createStore<span class="token punctuation">,</span> Reducer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'redux'</span>
<span class="token keyword">import</span> produce <span class="token keyword">from</span> <span class="token string">"immer"</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> combineReducers <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"redux-immer"</span>

<span class="token comment">// 聚合后的 reducer 和顶层应用数据</span>
<span class="token keyword">import</span> reducers<span class="token punctuation">,</span> <span class="token punctuation">{</span> AppState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./root-reducer"</span>

<span class="token comment">// 通过 combineReducer 将 reducer 合并为一</span>
<span class="token comment">// 注意这里的 combineReducers 是基于 immer 的实现</span>
<span class="token keyword">const</span> <span class="token literal-property property">rootReducer</span><span class="token operator">:</span> Reducer<span class="token operator">&lt;</span>AppState<span class="token operator">></span> <span class="token operator">=</span> <span class="token function">combineReducers</span><span class="token punctuation">(</span>produce<span class="token punctuation">,</span> reducers<span class="token punctuation">)</span>

<span class="token comment">// 导出 store</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">initialState <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">createStore</span><span class="token punctuation">(</span>
    rootReducer<span class="token punctuation">,</span>
    initialState<span class="token punctuation">,</span>
    <span class="token function">applyMiddleware</span><span class="token punctuation">(</span>Thunk<span class="token punctuation">,</span> promiseMiddleware<span class="token punctuation">,</span> Logger<span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="4-声明类型文件-dts">4. 声明类型文件 .d.ts</h3><p>我们在项目中会依赖到很多三方、二方包仍然是用纯 js 实现的，将这些代码重构为 <code>typescript</code> 显然是不现实的，ts 的做法是我们可以声明 <code>.d.ts</code> 类型文件将三方包引入到 ts 工程中。</p><p><code>.d.ts</code> 中 <code>d</code> 的含义是 <code>declaration</code> 即声明，实际使用我们无需关注具体实现，而只需要导出类型声明即可。</p><p>最简单的声明文件是这样的：</p><pre><code>declare module &#x27;@npm/r3&#x27;
</code></pre><p>但是如果你的项目中类型声明非常重要的话，建议到 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> 查看更多优质类型定义文件，并贡献自己的力量。</p><p>在声明类型文件还有一种<strong>取巧的做法</strong>是定义全局类型，全局类型无需导入即可对所有文件可见，举例：</p><p><em>typing.d.ts</em></p><pre><code>interface IUser {
  name: string
  phone: number
}
</code></pre><p>定义好之后你在任意文件中都可以直接使用该类型。</p><p>实际上这样做有可商榷之处，在导入三方类型声明的文件中，用来声明当前应用的全局类型。这样的做法 <a href="https://stackoverflow.com/questions/42233987/how-to-configure-custom-global-interfaces-d-ts-files-for-typescript">社区并不推荐</a>。实际上你应该定义一个独立的 <code>.ts</code> 文件，然后通过 <code>export/import</code> 来引用。</p><h2 id="三-reducer">三. reducer</h2><p>前面我们提到将 <code>reducer</code>，<code>action</code>，<code>actionType</code> 按照 <code>ducks</code> 规则统一到一个文件中管理, 并且将<strong>类型声明</strong>也统一到一个文件。接下来我们展开来介绍这部分内容：</p><h3 id="1-types">1. types</h3><p><code>actionType</code> 是一种可枚举类型：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">export</span> <span class="token keyword">enum</span> BitcoinActionTypes <span class="token punctuation">{</span>
  <span class="token comment">// 请求比特币周期价格指数</span>
  <span class="token constant">BITCOIN_QUERY_LIST</span> <span class="token operator">=</span> <span class="token string">"BITCOIN_QUERY_LIST"</span><span class="token punctuation">,</span>
  <span class="token comment">// 请求比特币当前价格</span>
  <span class="token constant">BITCOIN_QUERY_CURRENCY</span> <span class="token operator">=</span> <span class="token string">"BITCOIN_QUERY_CURRENCY"</span><span class="token punctuation">,</span>
  <span class="token comment">// 设置当前过滤条件</span>
  <span class="token constant">BITCOIN_SET_FILTER</span> <span class="token operator">=</span> <span class="token string">"BITCOIN_SET_FILTER"</span>
<span class="token punctuation">}</span>
</code></pre><p>通过枚举类型结合 <code>typescript</code> 的强类型自动推导能力，可以实现开发自动输入补全：
<img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2019-08-01-typescript-redux/image/infer.png" alt="enum"/></p><h3 id="2-actions">2. actions</h3><p>redux 中的 <code>action</code> 分为两类：同步和异步。</p><p><strong>同步 action</strong></p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">import</span> <span class="token punctuation">{</span> BitcoinActionTypes <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./types"</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">setFilterType</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">filterType</span><span class="token operator">:</span> string</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">type</span><span class="token operator">:</span> BitcoinActionTypes<span class="token punctuation">.</span><span class="token constant">BITCOIN_SET_FILTER</span><span class="token punctuation">,</span>
  <span class="token literal-property property">payload</span><span class="token operator">:</span> <span class="token punctuation">{</span> filterType <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>借助 <code>typeof</code> 关键词，我们在<code>types</code> 文件中非常方便地导出类型：</p><p><em>types.ts</em></p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">import</span> <span class="token punctuation">{</span> setFilterType <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./reducer"</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> type SetFilterType <span class="token operator">=</span> <span class="token keyword">typeof</span> setFilterType<span class="token punctuation">;</span>
</code></pre><p><strong>异步 action</strong></p><p>在项目中我们使用了 <a href="https://github.com/pburtchaell/redux-promise-middleware">redux-promise-middleware</a> 进行异步 action 的管理，异步 action 会返回 promise，但是写法仍然沿用同步 action 的写法。</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">import</span> <span class="token punctuation">{</span> AsyncAction <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"redux-promise-middleware"</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">const</span> queryBPICurrency <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token parameter">AsyncAction</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">type</span><span class="token operator">:</span> BitcoinActionTypes<span class="token punctuation">.</span><span class="token constant">BITCOIN_QUERY_CURRENCY</span><span class="token punctuation">,</span>
    <span class="token comment">// 这里这里payload 实际返回的是 promise</span>
    <span class="token literal-property property">payload</span><span class="token operator">:</span> axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"//api.coindesk.com/v1/bpi/currentprice/cny.json"</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>注意这里的 <code>AsyncAction</code> 来自 <code>redux-promise-middleware</code> 的 <a href="https://github.com/pburtchaell/redux-promise-middleware/blob/master/src/index.d.ts">类型定义</a>。</p><p>通过 <code>typeof</code> 类型推导:</p><p><em>types.ts</em></p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">import</span> <span class="token punctuation">{</span> queryBPI <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./reducer"</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> type QueryBPI <span class="token operator">=</span> <span class="token keyword">typeof</span> queryBPI
</code></pre><p>结果如下：</p><pre><code>type QueryBPI = (params: BPIParams) =&gt; AsyncAction
</code></pre><h3 id="3reducer">3.reducer</h3><p>结合<code>redux-promise-middleware</code>，<code>type-to-reducer</code> 和 <code>immer</code>，我们来完成具备类型的 <code>reducer</code>。</p><p><em>types.ts</em></p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token comment">// state 类型</span>
<span class="token comment">// 其中 Record 泛型是 `{ [key: string]: T }` 的简写</span>
<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">BitcoinState</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">filterType</span><span class="token operator">:</span> string<span class="token punctuation">;</span>
  <span class="token literal-property property">requestLoading</span><span class="token operator">:</span> boolean<span class="token punctuation">;</span>
  <span class="token literal-property property">currentPrice</span><span class="token operator">:</span> Record<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> BitcoinPrice<span class="token operator">></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p><strong>reducer.ts</strong></p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">import</span> typeToReducer <span class="token keyword">from</span> <span class="token string">"type-to-reducer"</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> BitcoinActionTypes<span class="token punctuation">,</span> BPIParams <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./types"</span><span class="token punctuation">;</span>

<span class="token comment">// 导出 reducer</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">typeToReducer</span><span class="token punctuation">(</span>
  <span class="token comment">// 同步 action</span>
  <span class="token punctuation">[</span>BitcoinActionTypes<span class="token punctuation">.</span><span class="token constant">BITCOIN_SET_FILTER</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> filterType <span class="token punctuation">}</span> <span class="token operator">=</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">;</span>
    <span class="token comment">// immer 包装后可以直接用原生 js 修改值</span>
    state<span class="token punctuation">.</span>filterType <span class="token operator">=</span> filterType<span class="token punctuation">;</span>
    <span class="token keyword">return</span> state<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// 异步action</span>
  BitcoinActionTypes<span class="token punctuation">.</span><span class="token constant">BITCOIN_QUERY_CURRENCY</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">PENDING</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>requestLoading <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token keyword">return</span> state
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">FULFILLED</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> <span class="token punctuation">{</span> bpi <span class="token punctuation">}</span> <span class="token operator">=</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">;</span>
      state<span class="token punctuation">.</span>currentPrice <span class="token operator">=</span> bpi<span class="token punctuation">;</span>
      <span class="token keyword">return</span> state<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre><h2 id="四-连接组件">四. 连接组件</h2><p>接下来我们将类型化后的 redux 连接到 React 组件：</p><h3 id="1-connect-连接">1. connect 连接</h3><p>react 组件和 redux 通过 <code>react-redux</code> 的 connect 方法进行连接：</p><pre><code class="language-javascript" data-language="javascript" data-highlighted-line-numbers=""><span class="token keyword">import</span> <span class="token punctuation">{</span> connect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"react-redux"</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> AppState <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"../../store/root-reducer"</span><span class="token punctuation">;</span>

<span class="token comment">// 导入类型</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>
  SetFilterType<span class="token punctuation">,</span>
  QueryBPICurrency<span class="token punctuation">,</span>
  QueryBPI<span class="token punctuation">,</span>
  BitcoinState<span class="token punctuation">,</span>
  BPIParams
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./types"</span>

<span class="token comment">// 类型扩展</span>
<span class="token keyword">interface</span> <span class="token class-name">BasicProps</span> <span class="token keyword">extends</span> <span class="token class-name">BitcoinState</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">setFilterType</span><span class="token operator">:</span> SetFilterType<span class="token punctuation">;</span>
  <span class="token literal-property property">queryBPICurrency</span><span class="token operator">:</span> QueryBPICurrency<span class="token punctuation">;</span>
  <span class="token literal-property property">queryBPI</span><span class="token operator">:</span> QueryBPI<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这里通过 Class 组件引入类型</span>
<span class="token comment">// 如果是函数式组件，就使用 React.FC&lt;BasicProps> 声明类型</span>
<span class="token keyword">class</span> <span class="token class-name">Basic</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token operator">&lt;</span>BasicProps<span class="token operator">></span><span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// do something</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 将 state 数据导出为属性</span>
<span class="token keyword">const</span> <span class="token function-variable function">select</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">state</span><span class="token operator">:</span> AppState</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> bitcoin <span class="token punctuation">}</span> <span class="token operator">=</span> state<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">requestLoading</span><span class="token operator">:</span> bitcoin<span class="token punctuation">.</span>requestLoading<span class="token punctuation">,</span>
    <span class="token literal-property property">filterType</span><span class="token operator">:</span> bitcoin<span class="token punctuation">.</span>filterType<span class="token punctuation">,</span>
    <span class="token literal-property property">currentPrice</span><span class="token operator">:</span> <span class="token function">get</span><span class="token punctuation">(</span>bitcoin<span class="token punctuation">,</span> <span class="token string">"currentPrice.CNY"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 最后一步：完成 redux 和 组件的连接</span>
<span class="token comment">// 顺便导入一下 action</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">connect</span><span class="token punctuation">(</span>
  select<span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    setFilterType<span class="token punctuation">,</span>
    queryBPI<span class="token punctuation">,</span>
    queryBPICurrency
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">(</span>Basic<span class="token punctuation">)</span>
</code></pre><p>到此，我们就基本上完成了一个 <code>typescript + redux + react</code> 的应用，<em>源码后续会放出</em>。</p><h2 id="总结">总结</h2><blockquote><p>这 ts 有什么用，限制多，运行慢，除了带给我一堆警告，还有什么作用？</p><p>ts 类型声明这么复杂，还引入了这么多新概念，跟框架兼容性又这么差</p><p>我就是辞职，不写前端了，也特么不用巨硬造的假 java</p><p>……</p><p>ts 真香，再也不想用 js 了。</p></blockquote><p>学习 <code>typescript</code> 是一段漫长的旅程，学习 ts 语法并不难，难的是框架对 ts 的支持度。以 React 为例，单单写一个 redux 版本的基础应用就踩了很多坑，甚至为了写 ts 不得不抛弃了<code>immutable.js</code>  — 一个数据不可变函数式工具，更不用提社区数量繁多的其他三方库了。</p><p>ts 不是银弹，ts 无法解决你的代码结构问题，也不能避免语法 Bug，<strong>”彼之蜜糖,吾之毒药“</strong>，当 ts 类型使用不当的时候，强行接入反而会给你造成更大的困扰。</p><p><strong>ts 适合什么场景？</strong></p><p>我个人认为:</p><ol><li><p>中大型项目，需要长期维护的项目，底层库 or 框架</p></li><li><p>上一条的前提是，项目主要依赖的类库对 ts 支持良好，最好有业界的先行案例</p></li></ol><p>所以用一些冷门框架或者小项目的时候我是不建议使用 ts 的，ts 没问题，框架也没问题，框架+ ts 会有很多问题。</p></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[查询 + Table 组件设计]]></title>
            <link>/blog/posts/2020-02-19/table-search-design/</link>
            <guid>/blog/posts/2020-02-19/table-search-design/</guid>
            <content:encoded><![CDATA[<div><h3 id="背景--目标">背景 &amp; 目标</h3><p>中后台系统的页面中多是查询+表格的展现形式，为了提高开发效率，减少重复的模版代码的书写，将公共能力收拢到组件，方便用户快速构建页面。</p><h3 id="产品现状">产品现状</h3><p>省略，参考自身业务</p><h3 id="产品要点梳理">产品要点梳理</h3><ol><li><p>查询和表格通常是一一对应，<strong>同时出现</strong> 的，也有场景是 <strong>只有表格，没有查询</strong> 。只有查询，没有表格目前系统很少见（<em>如果有的话，请帮忙补充</em>）。</p></li><li><p>查询组件只涉及到查询功能，不涉及到数据的更新操作，支持1个或多个数据共同查询，<strong>查询字段通常来源于表格字段</strong>，当然也开放自定义字段配置。</p></li><li><p>查询组件需要按列布局，也要支持<strong>展开/收缩</strong>，查询条件可以指定顺序，也可以默认按照表格列的顺序按先后放置，目前查询操作仅限于<strong>查询</strong>和<strong>重置</strong>。</p></li><li><p>表格组件<strong>数据源是动态</strong>的，需要通过查询条件向服务端发起请求，查询条件来自于<strong>查询组件</strong>，服务端请求需要做<strong>竞态处理（onLoad, onRequestError）</strong>，初始请求需要 <code>loading</code> 标识，查询参数来自于查询组件，以及自定义参数组合而成。</p></li><li><p>表格组件展示很灵活，包括 <strong>Title</strong>, <strong>ToolBar</strong>，并且表格组件通常会带有<strong>弹窗操作</strong>，弹窗需要获取当前 <strong>record</strong> 数据，操作完毕需要更新 Table。<code>ToolBar</code> 需要提供全局操作来更新表格（刷新）。</p></li><li><p>表格组件分页操作比较固定，每次查询重置当前页码，<code>page</code> 和 <code>pageSize</code> 变更重新发起请求，这一块公共逻辑需要统一封装，自定义的诉求比较少。</p></li><li><p>表格列组件有很多常见的开发情景：<strong>超出宽度文本<code>ellipsis</code></strong>，<strong>支持文本复制</strong>，<strong>字符filter（金额、时间、日期）</strong>，<strong>枚举状态处理</strong> 等等。列组件配置可以直接复用到查询表单组件上。</p></li></ol><h3 id="技术设计">技术设计</h3><p><code>List</code> 基于 Antd Table 进行扩展，封装了一些常用的 UI 和行为，通过将查询组件和 Table 组合起来，提供给用户一套标准化的组件实现。</p><h4 id="整体架构">整体架构</h4><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2020-02-19-table-search-design/image/arc.png" alt="list_设计"/></p><h4 id="组件-展示">组件 展示</h4><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2020-02-19-table-search-design/image/ui.png" alt="image"/></p><h4 id="api-设计">api 设计</h4><blockquote><p>该组件基于 <code>Antd Table</code> 扩展，默认支持 Table 所有属性，并且扩展下列其他属性：</p></blockquote><ul><li><p>应用实例</p><ul><li>actionRef：返回应用实例，对外提供公共方法，比如 refresh 等</li><li>formRef：查询表单实例</li><li>showSearch: 不展示查询栏，默认为 false</li></ul></li><li><p>数据请求</p><ul><li>request：返回一个 promise</li><li>params: 请求参数</li><li>onLoad: 每次请求完毕触发</li><li>onRequestError: 请求异常触发回调</li></ul></li><li><p>UI 展示</p><ul><li>Title：表格标题，支持 string 或者 ReactNode</li><li>ToolBar:  自动以工具栏组件，位于标题右侧</li><li>pagination: 继承 Table pagination，封装 page 和 pageSize 能力</li></ul></li><li><p>配置</p><ul><li>提供 columns 作为表格列和查询表单字段</li></ul><pre><code>key,
dataIndex,
width,
render,
valueType: 封装一些常见的类型filter，比如 dateTime, money 等
hideInSearch: 查询组件字段是否展示，默认为true
hideInTable: 不展示在Table 列，默认为 fasle
enum: 枚举类字段，比如状态（新建，已发布，已暂停等）
copy: 是否支持拷贝
ellipsis: 文本溢出自动展示
renderSearchItem:SearchItem 自定义展示
searchItemProps: SearchItem 配置
sort: 查询表单展示优先级
span: 表单项自定义宽度，优先于 searchConfig.span 执行
</code></pre></li><li><p>查询表单配置</p><ul><li>onSearch: 查询表单提交触发</li><li>onRest: 重置查询条件</li><li>searchConfig: 查询表单配置<ul><li>span: 列宽度，默认为8，参考 <code>antd cols</code></li><li>isCollpase: 当多行分布时是否折叠，默认为 <code>true</code></li><li>collpaseRows: 2, 最多未折叠展示行数</li><li>searchText: 搜索文本，默认<code>搜索</code></li><li>resetText: 重置文本，默认 <code>重置</code></li><li>collapseRender: 展开/收起 自定义渲染</li><li>needParamsToUrl：查询完毕更新 url，默认<code>false</code></li></ul></li></ul></li></ul><h4 id="列渲染逻辑">列渲染逻辑</h4><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2020-02-19-table-search-design/image/columnByTable.png" alt="column"/></p><h4 id="查询表单渲染逻辑">查询表单渲染逻辑</h4><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2020-02-19-table-search-design/image/columnBySearch.png" alt="查询表单渲染逻辑"/></p><h4 id="valuetype-设计">valueType 设计</h4><table><thead><tr><th>valueType</th><th>说明</th><th>搜索组件</th><th>Table</th><th>search</th></tr></thead><tbody><tr><td>money</td><td>金额千分符处理</td><td>InputNumber</td><td>✓</td><td>✓</td></tr><tr><td>date</td><td>日期处理</td><td>DatePicker</td><td>✓</td><td>✓</td></tr><tr><td>dateTime</td><td>日期+时间</td><td>DatePicker(showTime)</td><td>✓</td><td>✓</td></tr><tr><td>time</td><td>时间</td><td>TimePicker</td><td>✓</td><td>✓</td></tr><tr><td>dateRange</td><td>日期区间</td><td>RangePicker</td><td></td><td>✓</td></tr><tr><td>dateTimeRange</td><td>日期时间区间</td><td>RangePicker(showTime)</td><td></td><td>✓</td></tr><tr><td>checkbox</td><td>多选表单组件</td><td>checkbox</td><td></td><td>✓</td></tr><tr><td>radio</td><td>单选组件</td><td>radio</td><td></td><td>✓</td></tr><tr><td>inputNumber</td><td>数字输入组件</td><td>InputNumber</td><td></td><td>✓</td></tr><tr><td>textarea</td><td>文本域组件</td><td>TextArea</td><td></td><td>✓</td></tr></tbody></table></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[welcome]]></title>
            <link>/blog/posts/2020-03-07/welcome/</link>
            <guid>/blog/posts/2020-03-07/welcome/</guid>
            <content:encoded><![CDATA[<div><div><div class="document_logo__10KtI"><img src="/blog/static/media/react-logo.5d5d9eef.svg" class="document_logo-react__sXH7F" alt="logo"/></div><p><strong>1. 新建文章：</strong> 在 <code>src/routes/posts</code>下按照 <code>yyyy-mm-dd-your-page-title</code>创建文件夹，将 markdown 添加到 <code>document.mdx</code> 中，再新建 <code>post.js</code> 添加文章信息：</p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers=""><span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">文章标题</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
<span class="token literal-property property">tags</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'文章标签1'</span><span class="token punctuation">,</span> <span class="token string">'文章标签2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token literal-property property">spoiler</span><span class="token operator">:</span> <span class="token string">"文章简略说明"</span><span class="token punctuation">,</span>
<span class="token function-variable function">getContent</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./document.mdx'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</code></pre><p><strong>2. 编辑文章：</strong> 比如要修改当前文章，找到<code>src/routes/posts/2020-03-07-welcome/document.mdx</code>，修改后保存，页面会自动热更新。</p><p><strong>3. 修改页面主题：</strong> 编辑 <code>src/siteMetadata.js</code> metadata 属性。</p><p><strong>4. 编辑全局样式：</strong> 在 <code>src/index.module.css</code> 修改 css 即可.</p><p><strong>5. 代码高亮：</strong> 在对应的代码处添加花括号 {} 及对应行数，如 <code>jsx{1-4,6}</code>：</p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers="1,2,3,4,6"><span class="highlighted-line"><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span></span><span class="highlighted-line">  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span><span class="highlighted-line">    <span class="token keyword">return</span> <span class="token punctuation">(</span></span><span class="highlighted-line">      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">MyFunctionalComponent</span></span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>textInput<span class="token punctuation">}</span></span> <span class="token punctuation">/></span></span></span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="highlighted-line">  <span class="token punctuation">}</span></span><span class="token punctuation">}</span>
</code></pre><p><strong>7. 发布文章：</strong> 文章编辑完毕，直接 git push 即可，注意需要在 master 分支上操作。</p><h2 id="happy-bloging">happy bloging!</h2></div></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[浮生 6 载]]></title>
            <link>/blog/posts/2020-04-13/six-years-in-wacai/</link>
            <guid>/blog/posts/2020-04-13/six-years-in-wacai/</guid>
            <content:encoded><![CDATA[<div><h2 id="前言">前言</h2><p>几天前在群看到一只老视频，彼时的自己在项目小黑屋里面挑灯夜战，对着镜头谈笑风生，仿佛未来触手可及。多年以后再度重温，虽然间隔短短5年有余，仍是感觉白云苍狗，世事沧桑。</p><h2 id="入行">入行</h2><p>2014 年入行以来，挖财虽然不是完整的职业履历，却是一段难以忘怀的漫长生涯。见惯了业务的起起伏伏，也习惯了身边同事的来来往往，绕了如此一大圈，终于还是转身，切到了一条全新赛道，重新去面对新一轮的未知。</p><p>犹记得第一次去福地创业园的时候，雪刚刚停，长长的斜坡两边积满了雪花，静待春天的到来。彼时的互联网迎来了移动互联网的春天，一大波企业都在争先恐后的抢占赛道，当时的挖财也不例外，在我入职不久以后，借助之前的记账用户积累，很快就开始启动了理财 + 信贷的模式。在移动互联网助力下，借助互联网金融的普惠理念，挖财很快在互金领域站稳了脚跟。</p><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2020-04-13-six-years-in-wacai/image/518.jpg" alt="biz"/></p><blockquote><p>2015 518 活动</p></blockquote><p>互联网的速度令人震惊，我们在短短半年之内很快就做到了单日峰值10亿的规模，而当时我们整个开发团队甚至不到10人。彼时的我们深信前途终将一片灿烂，我们终将改变当前的金融生态。</p><p>在技术演进方面，14–15年恰逢 node.js 成熟的阶段，node.js 在 web 领域蓬勃发展，衍生了像 <code>gulp/webpack/express/koa</code> 等非常优秀的框架和工具，当时的理财团队也在公司内部率先尝试基于 node.js 的实践，我们做的第一步尝试是前端本地开发剥离 java 依赖，并且将古老的 jsp 替换为 相对更符合前端开发习惯的 velocity。当时团队大佬 @zhex 开发了非常优秀的 <a href="https://github.com/zhex/fe-dev-server">fds</a> 开发工具，可以让前端在本地通过 node.js 就可以启动 java 开发环境，非常牛叉。</p><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2020-04-13-six-years-in-wacai/image/lookback.png" alt="2015"/></p><blockquote><p>2015 年终回顾</p></blockquote><p>在验证了 node.js 本地环境替代 java 环境可行性的基础上，我们下一步要做的事情就是在生产环境也引入 node。业内当时的标准方案是 BFF（Backend For FrontEnd）。我们做的也不例外，当时采用的方案是 koa + jquery + nunjucks 的方案。node.js 在应用层面对前端很友好，然而客户端和服务端对 javascript 的定位完全不同，客户端我们更加关心页面性能、用户体验等，而服务端 javascript 扮演的角色更多的是通信、规模和效率。并且我们还要思考：</p><ul><li>如何打造一套分布式集群的 node 服务？</li><li>如何设计一套完整的应用开发、部署和回滚流程？</li><li>如何保证生产环境的应用运行得无懈可击？</li></ul><p>基于 node.js 在线上大规模应用之后，我们后续陆续打造了 node 发布系统、日志服务、监控告警等 node 周边生态链，让 node 成为了公司前端选型的统一标准。</p><p>16年之后，<code>React</code> 和 <code>Vue</code> 为代表的 <code>mvvm</code> 框架开始在社区火热起来，公司内部也分别有团队各自在生产环境运行。早期的 <code>React</code> 和 <code>Vue</code> 社区基本上是百家齐放，<code>Vue</code> 因为其上手成本低，开发配套方便吸引了一波早期用户，而 <code>React</code> 颠覆式的开发理念从一面世就吸引了广大开发者的眼光。</p><p>对一个公司而言，统一一套标准的开发框架带来的收益是巨大的，相对于 Vue，React 虚拟 DOM、JSX、单项数据流等虽有别于传统开发理念，在开发模式层面却提出了突破性的新方向。再加上 React 在社区生态上的繁荣，公司在前端选型方面就奠定了 React + Node 的基础框架。</p><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2020-04-13-six-years-in-wacai/image/qiandaohu.png" alt="千岛湖"/></p><blockquote><p>理财千岛湖团建</p></blockquote><p>2017 年国内互联网金融领域走上了一个巅峰，大大小小的 p2p、消费金融类公司开始野蛮生长，也为今后的互联网金融整顿埋下了隐患。可是，当时的我们哪有空想这些，看着每天不断上涨的数字，再加上媒体的各种推波作澜， 没有人会觉得末日就在眼前，然而所有命运赠送的财物，早已在暗中标记好了价格。</p><p>公司业务越来越多，在产品技术端，我们打算使用 react-native 开发新业务，一个 facebook 出品的移动端开发语言。<code>Learn once, write anywhere</code>，意味着你只要学会 <code>react</code>，用一套语言就可以开发安卓、IOS 应用。这对于企业来说诱惑太大了，原先分别要针对 安卓、ios、H5 开发三套版本，还要照顾各种平台兼容性，突然有一天，facebook 说你现在只要一套语言开发，就能够抹平三端的差异。理所当然得，公司2017开始了轰轰烈烈的 react native 改造计划。</p><p>现在回头来看，早期的 <code>react-native</code> 技术并不成熟，连接 <code>javascript</code> 和 <code>native</code> 之间的 bridge 通信效率极低，并且对于长列表也没有垃圾回收，导致应用的系统资源占用始终居高不下。我们做的第一个应用版本上线以后，饱受吐槽，不管是性能还是交互体验方面，不仅没有达到官方宣传的媲美 <code>native</code> 的体验，也丢失了 H5 一次部署，随时更新的动态能力。总体而言，<code>react native</code> 算不上一个好的 <code>native</code> 开发替代工具。</p><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2020-04-13-six-years-in-wacai/image/third-year.jpg" alt="3周年"/></p><blockquote><p>3 周年纪念</p></blockquote><h2 id="转岗">转岗</h2><p>17 年下半年走到了一个拐点上，一方面所在业务并没有起色，另一方面长期应付各种 C 端需求有点精疲力尽。是继续从事 C 端专注于 hybrid 开发，还是转战 B 端，去探索更多业务和数据逻辑？</p><p>当时纠结了许久，在跟 2B 的 TL 简单沟通之后，就愉快的决定转岗过来，接下来的第一个重要任务就是解锁团队可视化能力建设。</p><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2020-04-13-six-years-in-wacai/image/xihu.jpg" alt="西湖团建"/></p><blockquote><p>信贷端团建之西湖</p></blockquote><p>当时整个中后台团队了负责的业务跨度非常之大，从运维到大数据，从风控到用户，从贷前、贷中到贷后，从内部开发工具，到面向三方输出服务，都属于中后台团队的业务范畴。在业务扩展阶段，我们对于可视化的能力都是直接照搬开源工具。然而一旦涉及到深度定制环节，开源框架的限制就暴露出来了。我们的解决方案就是基于 D3 和 React 自研一套可视化框架，目前这套解决方案服务了全公司的可视化能力基建。</p><p>针对中后台系统开发模式统一的场景，我们团队开发了一套基于 <code>cli 脚手架</code> + <code>模板</code> + <code>node 中间件</code>的中后台解决方案。</p><p>在探索中后台系统可视化搭建方面，我们从业务组件库 + 配置服务入手，探索可视化搭建的可能性。</p><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2020-04-13-six-years-in-wacai/image/anji.png" alt="安吉团建"/></p><blockquote><p>信贷端团建之安吉</p></blockquote><h2 id="转折">转折</h2><p>2018年互金领域风云突变，年中伴随这买房摇号冻结政策的落地，p2p 开始了一轮大规模的暴雷，从此 p2p 暴雷成为了这两年令人胆颤心惊而又触耳可闻的新词。虽然挖财因为良好的风控措施和及时的政策调整避开了这波风暴，但覆巢之下，焉有完卵，整个互金产业爬坡爬了多年，好不容易爬到半坡，然后开始一路下滚，裹带着一路上泥沙草木，变成了滚雪球，越滚越大，什么时候会停下来？没人知道。</p><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2020-04-13-six-years-in-wacai/image/liangzhu.jpeg" alt="良渚团建"/></p><blockquote><p>工程平台团建</p></blockquote><p>19年之后，团队经历了一波震荡，我所在团队负责的领域却更加扩大了，我们开始参与 node.js 容器化平台的建设，还将公司内部端研发体系完成统一，并且开始搭建基于微前端 + 微服务的云平台治理架构。</p><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2020-04-13-six-years-in-wacai/image/kayan.png" alt="kayan"/></p><blockquote><p>卡宴欢送会</p></blockquote><p>2020 年，又是一个甲子年，真是一个令人永生难忘的年份，疫情施虐，巨星陨落，目睹了太多的生死离别，也见证了人性在灾难前的光辉闪耀。4 月 10 号，是我在挖财的 last day，在提交了最后一个 commit 之后，6 年零 46 天，划上了一个终点号。</p><p>这 6 年以来的挖财经历，经历了很多的告别，也将收获很多的重逢。要感谢的人很多，也就不一一在这里点名了，你们知道就好，不管未来身在何方，彼此在一起战斗的经历，会永驻心中，希望大家一切安好。</p><p><img src="https://github.com/wulucxy/blog/raw/master/src/routes/posts/2020-04-13-six-years-in-wacai/image/61-party.png" alt="61"/></p><blockquote><p>每年一度的挖财儿童节</p></blockquote><h2 id="尾声">尾声</h2><blockquote><p>经历的人不会都记起，过去的也不会都忘记，</p><p>有些事情有些回忆，成全了我也就陶冶了你。</p><p>《甲方乙方》</p></blockquote></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[低代码 + AI 发展方向调研]]></title>
            <link>/blog/posts/2023-03-30/lowcode-with-ai/</link>
            <guid>/blog/posts/2023-03-30/lowcode-with-ai/</guid>
            <content:encoded><![CDATA[<div><h2 id="背景">背景</h2><p>ChatGPT 由 由 Chat 与 GPT 两部分组成。</p><p>Chat 不重要，GPT 才重要。</p><p>那什么是 GPT，它的全英文是 Generative Pre-trained Transformer。</p><p>翻译过来就是「通用」「预训练」Transformer（不是变形金刚哦）。</p><p>「通用」代表业务领域，不用多说；</p><p>「预训练」简单理解为领域已有知识的汇总，有了这个知识储备，就能快速进入某一个领域；</p><p>Transformer 则是真正赋予 ChatGPT 生命力的灵魂，Transformer 是 NLP（自然语言处理）领域的变形金刚，自 2017 年出来以后，将之前如日中天的两大神经网络领域的卷王 RNN（循环神经网络），CNN（卷积神经网络）快卷没了。</p><p>真所谓，天下武功，唯卷无敌。</p><p>之所以介绍这段背景，是因为创建 Transformer 模型背后的公司也非常了不起，公司名叫 HuggingFace（笑脸）。</p><p>HuggingFace 提出 Transformer 模型的时候，NLP 领域的资源还比较匮乏，如日中天的还是 CV（计算机视觉）的各种 XNN，于是 HuggingFace 创建了同名开源社区（<a href="https://huggingface.co/%EF%BC%89%EF%BC%8C%E5%B9%B6%E5%BE%88%E5%BF%AB%E6%88%90%E4%B8%BA%E4%BA%86">https://huggingface.co/），并很快成为了</a> AI 领域开源模型、数据集等最大的社区，目前开源模型超过了 160000+，开源数据集也达到了 25000+，是当之无愧的 AI 领域的 github。</p><p>ChatGPT 一夜爆火的背后，其实就像黑夜逐渐泛白一样，当数量持续积累并突破阈值之后，时代的变化浩浩荡荡，一个新的时代正在冉冉升起。</p><h2 id="低代码和-ai-的关系">低代码和 AI 的关系</h2><p>在 chatGPT 出现之前，AI 和低代码的形态就已存在。</p><h3 id="1-ai-推理服务">1. AI 推理服务</h3><p><a href="https://github.com/illacloud/illa-builder">ILLA Builder</a> 是一款面向企业的低代码开发平台，对标（抄袭）的是国外知名的 retool（估计 20 亿美金）。ILLA 提供了连接器（link）的概念，可以快速接入外部数据平台（sql/excel/api）等，其中就包括对接了 huggingface inference api：</p><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/lowcode-with-ai/illa1.png" alt="image"/></p><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/lowcode-with-ai/illa2.png" alt="image"/></p><p>最终实现的效果如下：</p><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/lowcode-with-ai/illa3.gif" alt="huggingface"/></p><h3 id="2-sql-查询">2. sql 查询</h3><p>sql 本质上是特定领域（数据库）的一套结构化语言实现，在 chatGPT 之前已经有很多 NLP 模型实现了两者之间的转译，比如浙大发表的论文：<a href="https://github.com/yechens/NL2SQL">NL2SQL</a>，在测试数据集上已经实现了 65.3% 的准确率。</p><p>目前基于 GPT 实现 sql 查询产品也不少，比如：<a href="https://www.sqlchat.ai/">sqlchat</a>，是国内 DevOps 创业公司 bytebase 基于 chatGPT 推出了第一款交互式的 sql 生成工具。</p><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/lowcode-with-ai/sql.png" alt="image"/></p><h3 id="3-工作流">3. 工作流</h3><p>Retool 把自然语言查询能力直接集成了低代码的「工作流」模块，<a href="https://retool.com/blog/gpt4-in-retool/">链接</a>，操作步骤如下：</p><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/lowcode-with-ai/retool.png" alt="image"/></p><ol><li>选择数据源（sql/excel 等），设置触发周期（定时任务）</li><li>基于 gpt-4 输入文本描述（instruction），设置上下文变量</li><li>完成 sql 转译，并输出结果到下一个节点</li></ol><p>工作流 + 物料插件 + AI 模型理论上完全能够实现复杂的业务交互能力，对低代码的能力边界有了更大的想象力。</p><h3 id="4-引导式内容生成">4. 引导式内容生成</h3><p>引导式则将是通过一些面向用户的标准提问（Prompts），引导用户将需求清晰描述出来，然后用 GPT 生成格式化的输出，并由低代码引擎完成渲染。</p><p>和通过 GPT 生成文字和图片不同，代码平台对于 GPT 生成的内容的「准确度」和「结构化」程度要求更高，意味着对 GPT 模型的领域定制也会更深入。</p><p>来自杭州本地的创业公司 myBricks 低代码平台已经有了一定的雏形：</p><p><a href="https://mp.weixin.qq.com/s/7tzC2_DVaTro7Q0mkXGCzA">https://mp.weixin.qq.com/s/7tzC2_DVaTro7Q0mkXGCzA</a></p><p>以目前自研中的 TARS 低代码平台为例，一段页面级别的 schema 定义如下：</p><pre><code class="language-json" data-language="json" data-highlighted-line-numbers=""><span class="token punctuation">{</span>
  <span class="token property">"componentName"</span><span class="token operator">:</span> <span class="token string">"Root"</span><span class="token punctuation">,</span>
  <span class="token property">"children"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token property">"componentName"</span><span class="token operator">:</span> <span class="token string">"Form"</span><span class="token punctuation">,</span>
      <span class="token property">"props"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">"layout"</span><span class="token operator">:</span> <span class="token string">"horizontal"</span><span class="token punctuation">,</span>
        <span class="token property">"disabled"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
        <span class="token property">"style"</span><span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token property">"children"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
          <span class="token property">"componentName"</span><span class="token operator">:</span> <span class="token string">"FormItem"</span><span class="token punctuation">,</span>
          <span class="token property">"props"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">"名字"</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token property">"children"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
            <span class="token punctuation">{</span>
              <span class="token property">"componentName"</span><span class="token operator">:</span> <span class="token string">"Input"</span><span class="token punctuation">,</span>
              <span class="token property">"props"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                <span class="token property">"placeholder"</span><span class="token operator">:</span> <span class="token string">"请输入"</span><span class="token punctuation">,</span>
                <span class="token property">"value"</span><span class="token operator">:</span> <span class="token string">""</span>
              <span class="token punctuation">}</span><span class="token punctuation">,</span>
              <span class="token property">"x-field"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"string"</span><span class="token punctuation">,</span>
                <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"value"</span>
              <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>理论上后续基于大模型推理能力和大量的数据训练，生成针对 TARS 页面搭建的模型能力，就能直接通过录入这样一段 schema 来完成页面的搭建。</p><h2 id="总结">总结</h2><ol><li>低代码 和 GPT 可以相互融合，GPT 更适合通过插件集成的方式，进一步降低平台的开发成本；</li><li>已有的模型推理服务，可以直接在低代码平台使用；</li><li>GPT 对于一些结构化、模板化开发场景（sql、文档生成、测试用例）有潜在的优化可能；</li><li>GPT 和工作流场景天然匹配，补齐了低代码平台自定义交互的天然缺陷；</li><li>GPT 结合 Prompt 能够快速生成低代码 schema，但需要深度模型定制。</li></ol></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[从 Copilot 来看 LLM 应用落地]]></title>
            <link>/blog/posts/2023-04-05/copilot/</link>
            <guid>/blog/posts/2023-04-05/copilot/</guid>
            <content:encoded><![CDATA[<div><h2 id="1-背景">1. 背景</h2><p><a href="https://www.youtube.com/watch?v=S7xTBa93TX8">https://www.youtube.com/watch?v=S7xTBa93TX8</a></p><p>3 月 16 日，微软发布了集成了 ChatGPT 大模型的 Microsoft 365 Copilot 应用，针对普通打工人来说简直是降维打击。
Copilot（一个聊天机器人）可以帮助用户快速生成文章草稿，创建 PPT，数据整理和分析，生成会议记录/总结，
正如微软 CEO 纳德拉所言：从此我们的工作方式将永远改变，开启了新一轮的生产力大爆发。</p><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/copilot/copilot1.png" alt="image"/></p><p>作为一个战战兢兢的打工码农，一方面震惊于 AI 所开启的技术革命，另一方面也很好奇，作为一个聊天机器人，
从技术上是如何做到访问企业内部知识库，给出具备深度领域上下文知识的回答，并能根据用户反馈来优化输出？</p><p>当我把这个问题抛给 chatGPT，它是这么回答的：</p><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/copilot/chatgpt.png" alt="image"/></p><p>带着问题我们来看下， Copilot 背后的这套系统设计方案。</p><h2 id="2-copilot-系统设计">2. Copilot 系统设计</h2><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/copilot/copilot2.png" alt="image"/></p><ol><li><p>用户通过客户端提出问题，以「Prompt」的形式提供给 Copilot</p></li><li><p>Copilot 对问题进行 pre-processing（预处理），也被成为 grounding，本质上就是调用 Microsoft Graph
获取 prompt 的上下文知识（和问题相关的文档、链接、会话内容、邮件等）， Graph 可以认为是一个图数据库</p></li></ol><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/copilot/copilot3.png" alt="image"/></p><ol start="3"><li><p>通过 Graph 对 prompt 进行上下文增强以后，再次通过 Copilot 将真正的 Prompt 提交到 LLM（大语言模型）
这里包含了一个隐性信息：LLM 模型已经通过了大数据集的训练（trained），或是基于已有模型优化（fine-tuning），
但 LLM 本身不会访问已有现有的知识库，换句话说，LLM 是无状态的。</p></li><li><p>LLM 返回结果到 Copilot，会做一次 post-processing（后处理），后处理是包含了复杂的任务，如格式检查、安全验证、生成命令（唤起应用）等。</p></li></ol><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/copilot/copilot4.png" alt="image"/></p><ol start="5"><li>Copilot 将预处理的结果再返回给用户，包含了初始提问的上下文知识、应用命令等。通过 Copilot 可以将 Office 全家桶串联起来。</li></ol><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/copilot/copilot5.png" alt="image"/></p><h2 id="3-llm-平台架构">3. LLM 平台架构</h2><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/copilot/copilot_arc.png" alt="image"/></p><h2 id="4-可能风险">4. 可能风险</h2><p>GPT 大模型目前仍然处于早期阶段，在设计企业级大模型应用的角度来看，抛开高昂的实现成本（算力资源，
模型定制等）不说，还有很多业务问题需要在架构设计之前明确：</p><ol><li>数据隐私和安全风险：比如是否允许把敏感信息（用户信息）交给模型，模型如何保证信息不会被泄露，
以及用户可访问数据的权限控制？</li><li>结果的可解释性：大模型意味着没有人能够知道真正的内容生成逻辑，如何判断模型返回结果真实可信？</li><li>安全可信的 Prompt：针对不同角色，不同用户，不同场景设计不同的 Prompt？</li></ol></div>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[从实现原理看低代码]]></title>
            <link>/blog/posts/2023-07-28/principle-of-lowcode/</link>
            <guid>/blog/posts/2023-07-28/principle-of-lowcode/</guid>
            <content:encoded><![CDATA[<div><h1 id="从实现原理看低代码">从实现原理看低代码</h1><p>基于 TARS 低代码平台，你可以使用自然语言生成一个页面，并试着通过可视化搭建去完善它，必要的情况下，还能搭建一个具备完成交互功能的页面。</p><p>低代码到底有没有价值，你自己体验了才算。</p><h2 id="背景">背景</h2><p>TARS 低代码平台从 3 月份启动之后，即将迎来版本首发。最近也陆续上线多个应用：</p><ul><li>埋点报表</li><li>用户信息查询</li><li>资源池使用率</li><li>…</li></ul><p>这期间也调研了不少业内同类产品，各家产品实现细节上各有千秋，底层原理上也各有特色。</p><p>本文将基于 TARS 的实现原理，并结合同类竞品的实现范式，对低代码的本质进行简要拆解。</p><h2 id="低代码定义">低代码定义</h2><p>在 AIGC 🔥 出圈之前，低代码是科技领域的流量担当，大大小小的科技公司都在推出自己的低代码平台，同时围绕低代码充满了各种各样的争议。</p><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/principle-of-lowcode/products.png" alt="image"/></p><p>抛开现象看本质，头部分析机构 <code>Gartner</code> 对「低代码」给出的定义是：</p><pre><code>An LCAP is characterized by its use of model-driven or visual development paradigms
supported by expression languages and possibly scripting…

低代码应用开发平台的特征是，「模型驱动」，「可视化开发」，并支持「表达式」和「脚本开发」的能力。
</code></pre><p>低代码平台的出现和流行，其实是有其历史背景的。当 web 应用的前端技术和模型设计的基础越来越成熟，低代码平台就可以站在前人的肩膀上，将应用研发带入下一个阶段。</p><p>我认为低代码平台的核心能力是「可视化开发」，「可视化开发」并非单纯的拖拉拽做个页面，而是有着完整的「可视化代码开发」能力。</p><p>围绕「可视化开发」笔者将低代码平台核心能力可以进一步拆分为三块领域：</p><ol><li>可视化搭建</li><li>数据模型</li><li>逻辑编排</li></ol><h3 id="1-可视化搭建">1. 可视化搭建</h3><p>可视化搭建是开发者对低代码最直观的认知部分。使用者可基于可视化的画布，对画布上的节点进行可视化的配置和操作。</p><p>以 lowcode-engine 为例：
<img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/principle-of-lowcode/lowcode-engine-1.png" alt="image"/></p><p>可以发现，通常低代码可视化搭建至少包含以下元素：</p><ul><li>编辑器画布</li><li>组件库</li><li>组件配置器</li></ul><p>可视化搭建背后是一套描述页面结构和相关上下文的协议，一般称为 schema 或 DSL（本文统一为 schema）。</p><p>设计器内部会包含一套解析引擎，将 schema 解析为组件树，交给框架（react、vue、native）来渲染生成页面。</p><h4 id="schema">schema</h4><p>以 React 为例：</p><p>我们可以通过 JSON 来描述页面的结构：</p><pre><code class="language-json" data-language="json" data-highlighted-line-numbers=""><span class="token punctuation">{</span>
    <span class="token property">"componentName"</span><span class="token operator">:</span> <span class="token string">"Root"</span><span class="token punctuation">,</span>
    <span class="token property">"children"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
            <span class="token property">"componentName"</span><span class="token operator">:</span> <span class="token string">"Button"</span><span class="token punctuation">,</span>
            <span class="token property">"props"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
                <span class="token property">"size"</span><span class="token operator">:</span> <span class="token string">"default"</span>
                <span class="token property">"text"</span><span class="token operator">:</span> <span class="token string">"这是文本"</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">{</span>
            <span class="token property">"componentName"</span><span class="token operator">:</span> <span class="token string">"Input"</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre><p>其中 <code>componentName</code> 代表组件的唯一名称，<code>props</code> 代表组件属性，<code>children</code> 代表组件子节点。</p><p>通过平台内置渲染引擎生成结果：</p><pre><code class="language-jsx" data-language="jsx" data-highlighted-line-numbers=""><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Root</span></span><span class="token punctuation">></span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Button</span></span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>default<span class="token punctuation">"</span></span> <span class="token attr-name">text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>这是文本<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Input</span></span> <span class="token punctuation">/></span></span><span class="token plain-text">
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">Root</span></span><span class="token punctuation">></span></span><span class="token plain-text">
</span></code></pre><p>值得注意的是，目前绝大多数低代码平台 schema 都是采用 JSON 格式（也有 yaml、tsx 实现），原因有两点：</p><ol><li>JSON 格式对于前端比较友好，JS 原生支持</li><li>JSON 支持双向编辑，读取和写入一一对象</li></ol><p>其中第二点可以让使用者在平台上直接编辑或导入 JSON，对于熟悉的开发者来说，直接操作 JSON ，比在属性面板查找配置参数效率更高。</p><p>JSON 也有缺点：</p><ol><li>格式过于严格，比如必须双引号、行尾不能有分号等</li><li>不支持注释</li></ol><p>经常碰到的 case 就是 debug 半天，发现是少了一个双引号，特别奔溃…</p><h3 id="2-数据模型">2. 数据模型</h3><p>「可视化搭建」只是实现了将组件映射到画布的 UI 展示能力，实际场景下往往需要将数据绑定到 UI，并通过用户交互，将数据再提交到服务端。这一步在 TARS 上是通过「数据模型」来实现。</p><p>注意：</p><p>可视化设计器可分为「设计态」和「渲染态」，设计态可以修改组件配置，绑定数据字段，其中字段绑定并不立即生效。</p><p>预览态无法变更组件配置和数据绑定字段，但会根据设计态的配置生成实例信息</p><h4 id="场景-1表单提交">场景 1：表单提交</h4><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/principle-of-lowcode/tars1.png" alt="image"/></p><p>「渲染态」模式下用户在该表单项内输入的内容会存储到 <code>username</code> 字段</p><h4 id="场景-2接口获取">场景 2：接口获取</h4><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/principle-of-lowcode/tars2.png" alt="image"/></p><p>「渲染态」会从接口返回结果渲染对应表格字段</p><h3 id="场景-3组件联动">场景 3：组件联动</h3><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/principle-of-lowcode/tars3.png" alt="image"/></p><p>「渲染态」根据用户字段值变更动态展示组件</p><h4 id="实现原理">实现原理</h4><p>加入数据绑定逻辑之后，原有 schema 字段就不够用了，参考 <a href="https://formilyjs.org/zh-CN/">formily</a>，我们引入一个新的字段：<code>x-field</code> 用于数据绑定。</p><p>更新之后的 schema 定义：</p><pre><code>interface NodeSchema {
componentName: string;
  props?: {
    [key: string]: unknown;
  };
  &#x27;x-field&#x27;?: unknown;
  children?: NodeSchema[]
}
</code></pre><p><code>x-field</code> 的状态管理使用 redux 实现， redux 虽然代码比较繁琐，好处也是很明显的，数据流清晰明了，可以精确控制订阅。基于 immutable 的数据状态方便实现历史记录管理。</p><p><code>x-field</code> 可配置属性目前包括：</p><ul><li>name: 字段唯一名称，如 username</li><li>defaultValue：默认值，可配置 string/number/bool/exp/Date 等</li><li>valuePropName: 事件绑定字段，默认为 value，如果是 Radio 单选，需要配置未 checked</li><li>reactionMeta: 组件联动，支持可视化和表达式能力</li><li>validate rules: 暂不支持</li></ul><h5 id="渲染态实现">渲染态实现</h5><p>渲染态对于页面 schema 的渲染和设计态是一样的，通过组件递归实现页面组件树渲染。根据 schema 配置，如果配置了 <code>x-field</code> 字段，就给组件包裹一个 <code>windBind</code> 高阶组件。</p><p><code>withBind</code> 会接收 <code>x-field</code> 配置，并从 <code>redux</code> 中获取已绑定数据，完成数据绑定。</p><h3 id="3-交互逻辑">3. 交互逻辑</h3><p>有了可视化搭建和数据模型，仅仅是完成了单一组件级别渲染和数据绑定。实际应用内的逻辑往往比组件渲染复杂 N 倍，举一个管控类系统常见的 CRUD 查询功能为例：</p><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/principle-of-lowcode/tars4.png" alt="image"/></p><ol><li>给每个表单元素，表格列元素绑定相对应的字段</li><li>表单项每次变更需要更新查询条件，查询条件有可能还要获取外部变量</li><li>页面初始化、点击查询/重置、分页条件变更都需要发起异步请求</li><li>异步请求需要根据参数和访问路径进行缓存，参数变更则缓存失效</li><li>异步请求需要做好竞态管理，区分 loading、error、success 不同 UI 展示</li><li>异步请求前置参数、后置返回结果需要进行适配</li><li>异步远程 api 和低代码平台跨域处理</li><li>根据不同的返回结果类型，来决定自定义行为，比如显示弹窗、页面跳转等</li></ol><p>一个简单的 CRUD 查询和表格展示场景，涉及到页面级别组件的交互行为已然不少，这对于设计一套功能完备、符合使用体验、又具备足够灵活性的逻辑编排系统提出了很大的挑战。</p><h4 id="amis-方案">amis 方案</h4><p>amis 采用的是方案是「固化交互行为」，将一些常见的交互行为通过配置化实现，比如弹框是下面的配置：</p><pre><code class="language-json" data-language="json" data-highlighted-line-numbers=""><span class="token punctuation">{</span>
  <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">"弹框"</span><span class="token punctuation">,</span>
  <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"button"</span><span class="token punctuation">,</span>
  <span class="token property">"actionType"</span><span class="token operator">:</span> <span class="token string">"dialog"</span><span class="token punctuation">,</span> <span class="token comment">// actionType 固定交互行为</span>
  <span class="token property">"dialog"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"title"</span><span class="token operator">:</span> <span class="token string">"弹框"</span><span class="token punctuation">,</span>
    <span class="token property">"body"</span><span class="token operator">:</span> <span class="token string">"这是个简单的弹框。"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>amis 支持常见 <code>action</code> 行为类型：</p><ul><li>ui<ul><li>drawer: 抽屉</li><li>toast: 消息弹窗</li><li>dialog: 弹窗</li></ul></li><li>动作<ul><li>submit</li><li>clear</li><li>search</li><li>下载</li><li>跳转链接</li></ul></li><li>网络<ul><li>ajax</li></ul></li><li>表单<ul><li>校验</li><li>提交</li><li>重置</li></ul></li></ul><p>详细文档可参考：
<a href="https://aisuda.bce.baidu.com/amis/zh-CN/components/action?page=1">https://aisuda.bce.baidu.com/amis/zh-CN/components/action?page=1</a></p><h4 id="lowcode-engine-方案">lowcode-engine 方案</h4><p>lowcode-engine 采取了「javascript 编程」的方式，可视化界面只提供了组件搭建、属性配置的能力，一旦涉及到交互就需要通过手写 javascript 来实现。</p><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/principle-of-lowcode/lowcode-engine-2.png" alt="image"/></p><p>通过 javascript 实现的好处在于足够灵活，很多图形化界面难以表达的能力，可以很方便地用代码来实现。</p><p>太灵活当然也有缺陷，长期下来脚本满天飞，项目的可维护性和扩展性会遇到很多挑战。</p><h4 id="outsystems-方案">outSystems 方案</h4><p>outSystems 采取了流程图的策略，将各种逻辑交互能力做成一个元件，并对不同逻辑节点进行组合和串联，真正的逻辑由封装在节点中的函数完成。</p><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/principle-of-lowcode/outSystems-1.png" alt="image"/></p><p>基于流程图 schema，通过 AST 语法树编译，就可以转成代码。</p><p>示例如下：</p><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/principle-of-lowcode/outSystems-2.png" alt="image"/></p><p>可以看出，基于流程图实现业务逻辑编排，最终会生成一个完整业务逻辑实现。</p><p>流程图的特点在于强调整个流程的结构和步骤，从实现角度来说，更偏向于「面向过程」的脚本编程。</p><h4 id="blueprint-蓝图方案">BluePrint 蓝图方案</h4><p>BluePrint 最早由 unreal4 推出，主要用于游戏领域创建交互式程序。它允许非开发人员通过图形化界面来创建代码逻辑，而不需要编写传统代码。BluePrint 广泛用于游戏领域创建角色、动画、关卡、特效等，也可以用于创建游戏领域的交互流程、用户界面等。</p><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/principle-of-lowcode/bluePrint.png" alt="image"/></p><p>BluePrint 采用逻辑编排有别于「流程图」方案，BluePrint 逻辑元素包括输入和输出，前一个元素的输出作为下一个节点的输入，逻辑编排更加强调信息的流动和数据处理的过程，便于追踪数据流转的轨迹。</p><p>相对于「流程图」更加关注「面向过程」的脚本编程，「逻辑编排」方案基于数据流驱动的方式，更接近「面向对象」的实现。</p><p>基于以上的产品调研方案，TARS 设计逻辑编排模块选择的方案是更接近「Blueprint 蓝图」的实现。</p><h3 id="tars-设计方案">TARS 设计方案</h3><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/principle-of-lowcode/tars5.png" alt="image"/></p><p>TARS 逻辑编排包括以下定义：</p><ol><li>图编排</li><li>逻辑物料</li><li>编排函数</li><li>变量</li><li>图编排解析</li></ol><h4 id="1-图编排">1. 图编排</h4><p>「图编排」可分为「节点」和「连线」。</p><p>节点可以实现数据转换、网络请求、属性设置、变量操作等能力，一个节点可以有「输入」和「输出」端口。</p><p>连线用来连接各个节点，代表数据的流动关系。</p><h4 id="2-逻辑物料">2. 逻辑物料</h4><p>同可视化搭建一样，逻辑编排的物料也封装了部分业务逻辑，系统已经提供一些常见的物料，比如循环、合并/拆分数据、异步请求、组件操作等。</p><h4 id="3-编排函数">3. 编排函数</h4><p>逻辑物料编排之后的产物可以被复用，类似于编程语言里面的「函数」，「函数」具备和编排节点一样的输入、输出逻辑。</p><h4 id="4-变量">4. 变量</h4><p>变量可以被可视化搭建生成的组件消费，逻辑编排内部节点可以操作、监听上下文变量，变量可以在编排图里自由流动。</p><h4 id="5-图编排解析">5. 图编排解析</h4><p>逻辑编排生成的 schema 最终类似如下：</p><pre><code class="language-json" data-language="json" data-highlighted-line-numbers=""><span class="token punctuation">{</span>
    <span class="token property">"nodes"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"xx-xx"</span><span class="token punctuation">,</span>
        <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">"开始节点"</span><span class="token punctuation">,</span>
        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"StartNode"</span><span class="token punctuation">,</span>
        <span class="token property">"materialName"</span><span class="token operator">:</span> <span class="token string">"start"</span><span class="token punctuation">,</span>
        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"input"</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"xx"</span><span class="token punctuation">,</span>
        <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">"读取字段"</span><span class="token punctuation">,</span>
        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"DefaultNode"</span><span class="token punctuation">,</span>
        <span class="token property">"materialName"</span><span class="token operator">:</span> <span class="token string">"readFieldValue"</span><span class="token punctuation">,</span>
        <span class="token property">"inPorts"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
          <span class="token punctuation">{</span>
            <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"tEQUNgfb"</span><span class="token punctuation">,</span>
            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"input"</span><span class="token punctuation">,</span>
            <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">""</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token property">"outPorts"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
          <span class="token punctuation">{</span>
            <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"8p96kW7b"</span><span class="token punctuation">,</span>
            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"output"</span><span class="token punctuation">,</span>
            <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">""</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token property">"config"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token property">"fieldPath"</span><span class="token operator">:</span> <span class="token string">"userIdList"</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"xx-xx"</span><span class="token punctuation">,</span>
        <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">"异步请求"</span><span class="token punctuation">,</span>
        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"DefaultNode"</span><span class="token punctuation">,</span>
        <span class="token property">"materialName"</span><span class="token operator">:</span> <span class="token string">"request"</span><span class="token punctuation">,</span>
        <span class="token property">"inPorts"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
          <span class="token punctuation">{</span>
            <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"Xsul0sja"</span><span class="token punctuation">,</span>
            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"input"</span><span class="token punctuation">,</span>
            <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">""</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token property">"outPorts"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
          <span class="token punctuation">{</span>
            <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"6XBGQJJB"</span><span class="token punctuation">,</span>
            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"success"</span><span class="token punctuation">,</span>
            <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">"success"</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token punctuation">{</span>
            <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"RXsjBC68"</span><span class="token punctuation">,</span>
            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"loading"</span><span class="token punctuation">,</span>
            <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">"loading"</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token punctuation">{</span>
            <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"4jV6aZDL"</span><span class="token punctuation">,</span>
            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"error"</span><span class="token punctuation">,</span>
            <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">"error"</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token property">"config"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token property">"apiControl"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token property">"apiType"</span><span class="token operator">:</span> <span class="token string">"customApi"</span><span class="token punctuation">,</span>
            <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
              <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"http://alkaidos.cn/api/app/user-center/user/queryUserDetail"</span><span class="token punctuation">,</span>
              <span class="token property">"method"</span><span class="token operator">:</span> <span class="token string">"GET"</span>
            <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token property">"edges"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"xx-xx"</span><span class="token punctuation">,</span>
        <span class="token property">"source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token property">"nodeId"</span><span class="token operator">:</span> <span class="token string">"xx-xx"</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token property">"target"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token property">"nodeId"</span><span class="token operator">:</span> <span class="token string">"xx-xx"</span><span class="token punctuation">,</span>
          <span class="token property">"portId"</span><span class="token operator">:</span> <span class="token string">"xx-xx"</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span>
        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token string">"xx-xx"</span><span class="token punctuation">,</span>
        <span class="token property">"source"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token property">"nodeId"</span><span class="token operator">:</span> <span class="token string">"xx-xx"</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token property">"target"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token property">"nodeId"</span><span class="token operator">:</span> <span class="token string">"xx-xx"</span><span class="token punctuation">,</span>
          <span class="token property">"portId"</span><span class="token operator">:</span> <span class="token string">"xx-xx"</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>图编排解析引擎主要做两件事情：</p><ol><li>解析编排图上的所有节点（nodes），根据每个节点的「输入端口（inPorts）」和「输出端口（outPorts）」配置生成「连接点（jointer）」实例，每个「连接点」实例有从上游连接点（如果有）获取输入数据（inputValue），内部进行数据处理之后，传递给「输出端口」生成的「连接点」实例</li><li>解析所有连线（edges），连线逻辑相对简单，只负责建立「输出连接点」和「输入连接点」的关联，数据信息就会从上游节点的「输出连接点」流动到下游节点的「输入连接点」</li></ol><h4 id="demo-示例">DEMO 示例</h4><p>以一个管控平面类系统最为常见的表格查询场景为例：</p><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/principle-of-lowcode/tars6.png" alt="image"/></p><ol><li>定义一个变量：dataSource，作为表格的数据来源</li><li>定义一个函数图编排。函数图编排从「初始节点」开始，获取相应查询字段，
执行完合并逻辑，生成一个新查询对象，通过自定义的 js 方法进行数据组装（这一步非必需），
传递给「异步请求」节点，请求成功后将结果赋值给 dataSouce 变量</li></ol><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/principle-of-lowcode/tars7.png" alt="image"/></p><p>3.「查询按钮」订阅点击事件，触发函数图编排调用。</p><p><img src="https://raw.githubusercontent.com/wulucxy/blog/master/src/assets/imgs/posts/principle-of-lowcode/tars8.png" alt="image"/></p><ol start="4"><li>表格组件监听 <code>dataSource</code> 变量，每次变更后更新数据源属性。完成渲染。</li></ol><p>可以发现，基于逻辑图编排沿用了开发者的日常开发习惯，从定义变量、封装函数、事件监听到设置属性，对于开发者来说都是水到渠成。</p><p>每一个逻辑节点只需关心输入（input）和输出（output），业务逻辑都固化到节点内部，节点间功能相互独立，高内聚低耦合。</p><p>且节点间可以串联生成新的图节点，基于函数实现业务逻辑的可复用。</p><h2 id="one-more-thing">one more thing</h2><p>基于 AI 语言大模型和低代码的结合，是业界讨论的热点。TARS 在这方面也有了一些尝试，并在线上跑通了部分场景，具体效果怎样，后续有机会再分享。</p><h2 id="最后">最后</h2><ol><li>19 年前后，在上一家公司也参与过前端低代码平台的尝试，当时做的平台名也叫 TARS。
这次重新开始折腾，第一个想到的名称也是 TARS，也算是一种承前启后。</li><li>TARS 研发过程中得到了开源社区很多热心老师的帮助，很多灵感都来自于你们的启发，感恩。</li></ol></div>]]></content:encoded>
        </item>
    </channel>
</rss>